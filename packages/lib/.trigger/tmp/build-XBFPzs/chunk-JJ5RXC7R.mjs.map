{
  "version": 3,
  "sources": ["../../../../../node_modules/web-streams-polyfill/src/utils.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/helpers/miscellaneous.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/helpers/webidl.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/simple-queue.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/abstract-ops/internal-methods.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/readable-stream/generic-reader.ts", "../../../../../node_modules/web-streams-polyfill/src/stub/number-isfinite.ts", "../../../../../node_modules/web-streams-polyfill/src/stub/math-trunc.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/validators/basic.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/validators/readable-stream.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/readable-stream/default-reader.ts", "../../../../../node_modules/web-streams-polyfill/src/target/es2018/stub/async-iterator-prototype.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/readable-stream/async-iterator.ts", "../../../../../node_modules/web-streams-polyfill/src/stub/number-isnan.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/abstract-ops/ecmascript.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/abstract-ops/miscellaneous.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/abstract-ops/queue-with-sizes.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/helpers/array-buffer-view.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/readable-stream/byte-stream-controller.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/validators/reader-options.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/readable-stream/byob-reader.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/abstract-ops/queuing-strategy.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/validators/queuing-strategy.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/validators/underlying-sink.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/validators/writable-stream.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/abort-signal.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/writable-stream.ts", "../../../../../node_modules/web-streams-polyfill/src/globals.ts", "../../../../../node_modules/web-streams-polyfill/src/stub/dom-exception.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/readable-stream/pipe.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/readable-stream/default-controller.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/readable-stream/tee.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/readable-stream/readable-stream-like.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/readable-stream/from.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/validators/underlying-source.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/validators/iterator-options.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/validators/pipe-options.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/validators/readable-writable-pair.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/readable-stream.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/validators/queuing-strategy-init.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/byte-length-queuing-strategy.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/count-queuing-strategy.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/validators/transformer.ts", "../../../../../node_modules/web-streams-polyfill/src/lib/transform-stream.ts", "../../../../../node_modules/fetch-blob/streams.cjs", "../../../../../node_modules/node-domexception/index.js", "../../../../../node_modules/fetch-blob/file.js", "../../../../../node_modules/fetch-blob/index.js", "../../../../../node_modules/formdata-polyfill/esm.min.js", "../../../../../node_modules/fetch-blob/from.js"],
  "sourcesContent": ["export function noop(): undefined {\n  return undefined;\n}\n", "import { noop } from '../../utils';\nimport { AssertionError } from '../../stub/assert';\n\nexport function typeIsObject(x: any): x is object {\n  return (typeof x === 'object' && x !== null) || typeof x === 'function';\n}\n\nexport const rethrowAssertionErrorRejection: (e: any) => void =\n  DEBUG ? e => {\n    // Used throughout the reference implementation, as `.catch(rethrowAssertionErrorRejection)`, to ensure any errors\n    // get shown. There are places in the spec where we do promise transformations and purposefully ignore or don't\n    // expect any errors, but assertion errors are always problematic.\n    if (e && e instanceof AssertionError) {\n      setTimeout(() => {\n        throw e;\n      }, 0);\n    }\n  } : noop;\n\nexport function setFunctionName(fn: Function, name: string): void {\n  try {\n    Object.defineProperty(fn, 'name', {\n      value: name,\n      configurable: true\n    });\n  } catch {\n    // This property is non-configurable in older browsers, so ignore if this throws.\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility\n  }\n}\n", "import { rethrowAssertionErrorRejection } from './miscellaneous';\nimport assert from '../../stub/assert';\n\nconst originalPromise = Promise;\nconst originalPromiseThen = Promise.prototype.then;\nconst originalPromiseReject = Promise.reject.bind(originalPromise);\n\n// https://webidl.spec.whatwg.org/#a-new-promise\nexport function newPromise<T>(executor: (\n  resolve: (value: T | PromiseLike<T>) => void,\n  reject: (reason?: any) => void\n) => void): Promise<T> {\n  return new originalPromise(executor);\n}\n\n// https://webidl.spec.whatwg.org/#a-promise-resolved-with\nexport function promiseResolvedWith<T>(value: T | PromiseLike<T>): Promise<T> {\n  return newPromise(resolve => resolve(value));\n}\n\n// https://webidl.spec.whatwg.org/#a-promise-rejected-with\nexport function promiseRejectedWith<T = never>(reason: any): Promise<T> {\n  return originalPromiseReject(reason);\n}\n\nexport function PerformPromiseThen<T, TResult1 = T, TResult2 = never>(\n  promise: Promise<T>,\n  onFulfilled?: (value: T) => TResult1 | PromiseLike<TResult1>,\n  onRejected?: (reason: any) => TResult2 | PromiseLike<TResult2>): Promise<TResult1 | TResult2> {\n  // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an\n  // approximation.\n  return originalPromiseThen.call(promise, onFulfilled, onRejected) as Promise<TResult1 | TResult2>;\n}\n\n// Bluebird logs a warning when a promise is created within a fulfillment handler, but then isn't returned\n// from that handler. To prevent this, return null instead of void from all handlers.\n// http://bluebirdjs.com/docs/warning-explanations.html#warning-a-promise-was-created-in-a-handler-but-was-not-returned-from-it\nexport function uponPromise<T>(\n  promise: Promise<T>,\n  onFulfilled?: (value: T) => null | PromiseLike<null>,\n  onRejected?: (reason: any) => null | PromiseLike<null>): void {\n  PerformPromiseThen(\n    PerformPromiseThen(promise, onFulfilled, onRejected),\n    undefined,\n    rethrowAssertionErrorRejection\n  );\n}\n\nexport function uponFulfillment<T>(promise: Promise<T>, onFulfilled: (value: T) => null | PromiseLike<null>): void {\n  uponPromise(promise, onFulfilled);\n}\n\nexport function uponRejection(promise: Promise<unknown>, onRejected: (reason: any) => null | PromiseLike<null>): void {\n  uponPromise(promise, undefined, onRejected);\n}\n\nexport function transformPromiseWith<T, TResult1 = T, TResult2 = never>(\n  promise: Promise<T>,\n  fulfillmentHandler?: (value: T) => TResult1 | PromiseLike<TResult1>,\n  rejectionHandler?: (reason: any) => TResult2 | PromiseLike<TResult2>): Promise<TResult1 | TResult2> {\n  return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\n}\n\nexport function setPromiseIsHandledToTrue(promise: Promise<unknown>): void {\n  PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);\n}\n\nlet _queueMicrotask: (callback: () => void) => void = callback => {\n  if (typeof queueMicrotask === 'function') {\n    _queueMicrotask = queueMicrotask;\n  } else {\n    const resolvedPromise = promiseResolvedWith(undefined);\n    _queueMicrotask = cb => PerformPromiseThen(resolvedPromise, cb);\n  }\n  return _queueMicrotask(callback);\n};\n\nexport { _queueMicrotask as queueMicrotask };\n\nexport function reflectCall<T, A extends any[], R>(F: (this: T, ...fnArgs: A) => R, V: T, args: A): R {\n  if (typeof F !== 'function') {\n    throw new TypeError('Argument is not a function');\n  }\n  return Function.prototype.apply.call(F, V, args);\n}\n\nexport function promiseCall<T, A extends any[], R>(F: (this: T, ...fnArgs: A) => R | PromiseLike<R>,\n                                                   V: T,\n                                                   args: A): Promise<R> {\n  assert(typeof F === 'function');\n  assert(V !== undefined);\n  assert(Array.isArray(args));\n  try {\n    return promiseResolvedWith(reflectCall(F, V, args));\n  } catch (value) {\n    return promiseRejectedWith(value);\n  }\n}\n", "import assert from '../stub/assert';\n\n// Original from Chromium\n// https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js\n\nconst QUEUE_MAX_ARRAY_SIZE = 16384;\n\ninterface Node<T> {\n  _elements: T[];\n  _next: Node<T> | undefined;\n}\n\n/**\n * Simple queue structure.\n *\n * Avoids scalability issues with using a packed array directly by using\n * multiple arrays in a linked list and keeping the array size bounded.\n */\nexport class SimpleQueue<T> {\n  private _front: Node<T>;\n  private _back: Node<T>;\n  private _cursor = 0;\n  private _size = 0;\n\n  constructor() {\n    // _front and _back are always defined.\n    this._front = {\n      _elements: [],\n      _next: undefined\n    };\n    this._back = this._front;\n    // The cursor is used to avoid calling Array.shift().\n    // It contains the index of the front element of the array inside the\n    // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).\n    this._cursor = 0;\n    // When there is only one node, size === elements.length - cursor.\n    this._size = 0;\n  }\n\n  get length(): number {\n    return this._size;\n  }\n\n  // For exception safety, this method is structured in order:\n  // 1. Read state\n  // 2. Calculate required state mutations\n  // 3. Perform state mutations\n  push(element: T): void {\n    const oldBack = this._back;\n    let newBack = oldBack;\n    assert(oldBack._next === undefined);\n    if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {\n      newBack = {\n        _elements: [],\n        _next: undefined\n      };\n    }\n\n    // push() is the mutation most likely to throw an exception, so it\n    // goes first.\n    oldBack._elements.push(element);\n    if (newBack !== oldBack) {\n      this._back = newBack;\n      oldBack._next = newBack;\n    }\n    ++this._size;\n  }\n\n  // Like push(), shift() follows the read -> calculate -> mutate pattern for\n  // exception safety.\n  shift(): T {\n    assert(this._size > 0); // must not be called on an empty queue\n\n    const oldFront = this._front;\n    let newFront = oldFront;\n    const oldCursor = this._cursor;\n    let newCursor = oldCursor + 1;\n\n    const elements = oldFront._elements;\n    const element = elements[oldCursor];\n\n    if (newCursor === QUEUE_MAX_ARRAY_SIZE) {\n      assert(elements.length === QUEUE_MAX_ARRAY_SIZE);\n      assert(oldFront._next !== undefined);\n      newFront = oldFront._next!;\n      newCursor = 0;\n    }\n\n    // No mutations before this point.\n    --this._size;\n    this._cursor = newCursor;\n    if (oldFront !== newFront) {\n      this._front = newFront;\n    }\n\n    // Permit shifted element to be garbage collected.\n    elements[oldCursor] = undefined!;\n\n    return element;\n  }\n\n  // The tricky thing about forEach() is that it can be called\n  // re-entrantly. The queue may be mutated inside the callback. It is easy to\n  // see that push() within the callback has no negative effects since the end\n  // of the queue is checked for on every iteration. If shift() is called\n  // repeatedly within the callback then the next iteration may return an\n  // element that has been removed. In this case the callback will be called\n  // with undefined values until we either \"catch up\" with elements that still\n  // exist or reach the back of the queue.\n  forEach(callback: (element: T) => void): void {\n    let i = this._cursor;\n    let node = this._front;\n    let elements = node._elements;\n    while (i !== elements.length || node._next !== undefined) {\n      if (i === elements.length) {\n        assert(node._next !== undefined);\n        assert(i === QUEUE_MAX_ARRAY_SIZE);\n        node = node._next!;\n        elements = node._elements;\n        i = 0;\n        if (elements.length === 0) {\n          break;\n        }\n      }\n      callback(elements[i]);\n      ++i;\n    }\n  }\n\n  // Return the element that would be returned if shift() was called now,\n  // without modifying the queue.\n  peek(): T {\n    assert(this._size > 0); // must not be called on an empty queue\n\n    const front = this._front;\n    const cursor = this._cursor;\n    return front._elements[cursor];\n  }\n}\n", "export const AbortSteps = Symbol('[[AbortSteps]]');\nexport const ErrorSteps = Symbol('[[ErrorSteps]]');\nexport const CancelSteps = Symbol('[[CancelSteps]]');\nexport const PullSteps = Symbol('[[PullSteps]]');\nexport const ReleaseSteps = Symbol('[[ReleaseSteps]]');\n", "import assert from '../../stub/assert';\nimport { ReadableStream, ReadableStreamCancel, type ReadableStreamReader } from '../readable-stream';\nimport { newPromise, setPromiseIsHandledToTrue } from '../helpers/webidl';\nimport { ReleaseSteps } from '../abstract-ops/internal-methods';\n\nexport function ReadableStreamReaderGenericInitialize<R>(reader: ReadableStreamReader<R>, stream: ReadableStream<R>) {\n  reader._ownerReadableStream = stream;\n  stream._reader = reader;\n\n  if (stream._state === 'readable') {\n    defaultReaderClosedPromiseInitialize(reader);\n  } else if (stream._state === 'closed') {\n    defaultReaderClosedPromiseInitializeAsResolved(reader);\n  } else {\n    assert(stream._state === 'errored');\n\n    defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n  }\n}\n\n// A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n// check.\n\nexport function ReadableStreamReaderGenericCancel(reader: ReadableStreamReader<any>, reason: any): Promise<undefined> {\n  const stream = reader._ownerReadableStream;\n  assert(stream !== undefined);\n  return ReadableStreamCancel(stream, reason);\n}\n\nexport function ReadableStreamReaderGenericRelease(reader: ReadableStreamReader<any>) {\n  const stream = reader._ownerReadableStream;\n  assert(stream !== undefined);\n  assert(stream._reader === reader);\n\n  if (stream._state === 'readable') {\n    defaultReaderClosedPromiseReject(\n      reader,\n      new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n  } else {\n    defaultReaderClosedPromiseResetToRejected(\n      reader,\n      new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n  }\n\n  stream._readableStreamController[ReleaseSteps]();\n\n  stream._reader = undefined;\n  reader._ownerReadableStream = undefined!;\n}\n\n// Helper functions for the readers.\n\nexport function readerLockException(name: string): TypeError {\n  return new TypeError('Cannot ' + name + ' a stream using a released reader');\n}\n\n// Helper functions for the ReadableStreamDefaultReader.\n\nexport function defaultReaderClosedPromiseInitialize(reader: ReadableStreamReader<any>) {\n  reader._closedPromise = newPromise((resolve, reject) => {\n    reader._closedPromise_resolve = resolve;\n    reader._closedPromise_reject = reject;\n  });\n}\n\nexport function defaultReaderClosedPromiseInitializeAsRejected(reader: ReadableStreamReader<any>, reason: any) {\n  defaultReaderClosedPromiseInitialize(reader);\n  defaultReaderClosedPromiseReject(reader, reason);\n}\n\nexport function defaultReaderClosedPromiseInitializeAsResolved(reader: ReadableStreamReader<any>) {\n  defaultReaderClosedPromiseInitialize(reader);\n  defaultReaderClosedPromiseResolve(reader);\n}\n\nexport function defaultReaderClosedPromiseReject(reader: ReadableStreamReader<any>, reason: any) {\n  if (reader._closedPromise_reject === undefined) {\n    return;\n  }\n\n  setPromiseIsHandledToTrue(reader._closedPromise);\n  reader._closedPromise_reject(reason);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nexport function defaultReaderClosedPromiseResetToRejected(reader: ReadableStreamReader<any>, reason: any) {\n  assert(reader._closedPromise_resolve === undefined);\n  assert(reader._closedPromise_reject === undefined);\n\n  defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n}\n\nexport function defaultReaderClosedPromiseResolve(reader: ReadableStreamReader<any>) {\n  if (reader._closedPromise_resolve === undefined) {\n    return;\n  }\n\n  reader._closedPromise_resolve(undefined);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n", "/// <reference lib=\"es2015.core\" />\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill\nconst NumberIsFinite: typeof Number.isFinite = Number.isFinite || function (x) {\n  return typeof x === 'number' && isFinite(x);\n};\n\nexport default NumberIsFinite;\n", "/// <reference lib=\"es2015.core\" />\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill\nconst MathTrunc: typeof Math.trunc = Math.trunc || function (v) {\n  return v < 0 ? Math.ceil(v) : Math.floor(v);\n};\n\nexport default MathTrunc;\n", "import NumberIsFinite from '../../stub/number-isfinite';\nimport MathTrunc from '../../stub/math-trunc';\n\n// https://heycam.github.io/webidl/#idl-dictionaries\nexport function isDictionary(x: any): x is object | null {\n  return typeof x === 'object' || typeof x === 'function';\n}\n\nexport function assertDictionary(obj: unknown,\n                                 context: string): asserts obj is object | null | undefined {\n  if (obj !== undefined && !isDictionary(obj)) {\n    throw new TypeError(`${context} is not an object.`);\n  }\n}\n\nexport type AnyFunction = (...args: any[]) => any;\n\n// https://heycam.github.io/webidl/#idl-callback-functions\nexport function assertFunction(x: unknown, context: string): asserts x is AnyFunction {\n  if (typeof x !== 'function') {\n    throw new TypeError(`${context} is not a function.`);\n  }\n}\n\n// https://heycam.github.io/webidl/#idl-object\nexport function isObject(x: any): x is object {\n  return (typeof x === 'object' && x !== null) || typeof x === 'function';\n}\n\nexport function assertObject(x: unknown,\n                             context: string): asserts x is object {\n  if (!isObject(x)) {\n    throw new TypeError(`${context} is not an object.`);\n  }\n}\n\nexport function assertRequiredArgument<T>(x: T | undefined,\n                                          position: number,\n                                          context: string): asserts x is T {\n  if (x === undefined) {\n    throw new TypeError(`Parameter ${position} is required in '${context}'.`);\n  }\n}\n\nexport function assertRequiredField<T>(x: T | undefined,\n                                       field: string,\n                                       context: string): asserts x is T {\n  if (x === undefined) {\n    throw new TypeError(`${field} is required in '${context}'.`);\n  }\n}\n\n// https://heycam.github.io/webidl/#idl-unrestricted-double\nexport function convertUnrestrictedDouble(value: unknown): number {\n  return Number(value);\n}\n\nfunction censorNegativeZero(x: number): number {\n  return x === 0 ? 0 : x;\n}\n\nfunction integerPart(x: number): number {\n  return censorNegativeZero(MathTrunc(x));\n}\n\n// https://heycam.github.io/webidl/#idl-unsigned-long-long\nexport function convertUnsignedLongLongWithEnforceRange(value: unknown, context: string): number {\n  const lowerBound = 0;\n  const upperBound = Number.MAX_SAFE_INTEGER;\n\n  let x = Number(value);\n  x = censorNegativeZero(x);\n\n  if (!NumberIsFinite(x)) {\n    throw new TypeError(`${context} is not a finite number`);\n  }\n\n  x = integerPart(x);\n\n  if (x < lowerBound || x > upperBound) {\n    throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);\n  }\n\n  if (!NumberIsFinite(x) || x === 0) {\n    return 0;\n  }\n\n  // TODO Use BigInt if supported?\n  // let xBigInt = BigInt(integerPart(x));\n  // xBigInt = BigInt.asUintN(64, xBigInt);\n  // return Number(xBigInt);\n\n  return x;\n}\n", "import { IsReadableStream, ReadableStream } from '../readable-stream';\n\nexport function assertReadableStream(x: unknown, context: string): asserts x is ReadableStream {\n  if (!IsReadableStream(x)) {\n    throw new TypeError(`${context} is not a ReadableStream.`);\n  }\n}\n", "import assert from '../../stub/assert';\nimport { SimpleQueue } from '../simple-queue';\nimport {\n  ReadableStreamReaderGenericCancel,\n  ReadableStreamReaderGenericInitialize,\n  ReadableStreamReaderGenericRelease,\n  readerLockException\n} from './generic-reader';\nimport { IsReadableStreamLocked, ReadableStream } from '../readable-stream';\nimport { setFunctionName, typeIsObject } from '../helpers/miscellaneous';\nimport { PullSteps } from '../abstract-ops/internal-methods';\nimport { newPromise, promiseRejectedWith } from '../helpers/webidl';\nimport { assertRequiredArgument } from '../validators/basic';\nimport { assertReadableStream } from '../validators/readable-stream';\n\n/**\n * A result returned by {@link ReadableStreamDefaultReader.read}.\n *\n * @public\n */\nexport type ReadableStreamDefaultReadResult<T> = {\n  done: false;\n  value: T;\n} | {\n  done: true;\n  value?: undefined;\n}\n\n// Abstract operations for the ReadableStream.\n\nexport function AcquireReadableStreamDefaultReader<R>(stream: ReadableStream): ReadableStreamDefaultReader<R> {\n  return new ReadableStreamDefaultReader(stream);\n}\n\n// ReadableStream API exposed for controllers.\n\nexport function ReadableStreamAddReadRequest<R>(stream: ReadableStream<R>,\n                                                readRequest: ReadRequest<R>): void {\n  assert(IsReadableStreamDefaultReader(stream._reader));\n  assert(stream._state === 'readable');\n\n  (stream._reader! as ReadableStreamDefaultReader<R>)._readRequests.push(readRequest);\n}\n\nexport function ReadableStreamFulfillReadRequest<R>(stream: ReadableStream<R>, chunk: R | undefined, done: boolean) {\n  const reader = stream._reader as ReadableStreamDefaultReader<R>;\n\n  assert(reader._readRequests.length > 0);\n\n  const readRequest = reader._readRequests.shift()!;\n  if (done) {\n    readRequest._closeSteps();\n  } else {\n    readRequest._chunkSteps(chunk!);\n  }\n}\n\nexport function ReadableStreamGetNumReadRequests<R>(stream: ReadableStream<R>): number {\n  return (stream._reader as ReadableStreamDefaultReader<R>)._readRequests.length;\n}\n\nexport function ReadableStreamHasDefaultReader(stream: ReadableStream): boolean {\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (!IsReadableStreamDefaultReader(reader)) {\n    return false;\n  }\n\n  return true;\n}\n\n// Readers\n\nexport interface ReadRequest<R> {\n  _chunkSteps(chunk: R): void;\n\n  _closeSteps(): void;\n\n  _errorSteps(e: any): void;\n}\n\n/**\n * A default reader vended by a {@link ReadableStream}.\n *\n * @public\n */\nexport class ReadableStreamDefaultReader<R = any> {\n  /** @internal */\n  _ownerReadableStream!: ReadableStream<R>;\n  /** @internal */\n  _closedPromise!: Promise<undefined>;\n  /** @internal */\n  _closedPromise_resolve?: (value?: undefined) => void;\n  /** @internal */\n  _closedPromise_reject?: (reason: any) => void;\n  /** @internal */\n  _readRequests: SimpleQueue<ReadRequest<R>>;\n\n  constructor(stream: ReadableStream<R>) {\n    assertRequiredArgument(stream, 1, 'ReadableStreamDefaultReader');\n    assertReadableStream(stream, 'First parameter');\n\n    if (IsReadableStreamLocked(stream)) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n\n    this._readRequests = new SimpleQueue();\n  }\n\n  /**\n   * Returns a promise that will be fulfilled when the stream becomes closed,\n   * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.\n   */\n  get closed(): Promise<undefined> {\n    if (!IsReadableStreamDefaultReader(this)) {\n      return promiseRejectedWith(defaultReaderBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  /**\n   * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n   */\n  cancel(reason: any = undefined): Promise<void> {\n    if (!IsReadableStreamDefaultReader(this)) {\n      return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n\n  /**\n   * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.\n   *\n   * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n   */\n  read(): Promise<ReadableStreamDefaultReadResult<R>> {\n    if (!IsReadableStreamDefaultReader(this)) {\n      return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('read from'));\n    }\n\n    let resolvePromise!: (result: ReadableStreamDefaultReadResult<R>) => void;\n    let rejectPromise!: (reason: any) => void;\n    const promise = newPromise<ReadableStreamDefaultReadResult<R>>((resolve, reject) => {\n      resolvePromise = resolve;\n      rejectPromise = reject;\n    });\n    const readRequest: ReadRequest<R> = {\n      _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n      _closeSteps: () => resolvePromise({ value: undefined, done: true }),\n      _errorSteps: e => rejectPromise(e)\n    };\n    ReadableStreamDefaultReaderRead(this, readRequest);\n    return promise;\n  }\n\n  /**\n   * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n   * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n   * from now on; otherwise, the reader will appear closed.\n   *\n   * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n   * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n   * do so will throw a `TypeError` and leave the reader locked to the stream.\n   */\n  releaseLock(): void {\n    if (!IsReadableStreamDefaultReader(this)) {\n      throw defaultReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    ReadableStreamDefaultReaderRelease(this);\n  }\n}\n\nObject.defineProperties(ReadableStreamDefaultReader.prototype, {\n  cancel: { enumerable: true },\n  read: { enumerable: true },\n  releaseLock: { enumerable: true },\n  closed: { enumerable: true }\n});\nsetFunctionName(ReadableStreamDefaultReader.prototype.cancel, 'cancel');\nsetFunctionName(ReadableStreamDefaultReader.prototype.read, 'read');\nsetFunctionName(ReadableStreamDefaultReader.prototype.releaseLock, 'releaseLock');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStreamDefaultReader.prototype, Symbol.toStringTag, {\n    value: 'ReadableStreamDefaultReader',\n    configurable: true\n  });\n}\n\n// Abstract operations for the readers.\n\nexport function IsReadableStreamDefaultReader<R = any>(x: any): x is ReadableStreamDefaultReader<R> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\n    return false;\n  }\n\n  return x instanceof ReadableStreamDefaultReader;\n}\n\nexport function ReadableStreamDefaultReaderRead<R>(reader: ReadableStreamDefaultReader<R>,\n                                                   readRequest: ReadRequest<R>): void {\n  const stream = reader._ownerReadableStream;\n\n  assert(stream !== undefined);\n\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    readRequest._closeSteps();\n  } else if (stream._state === 'errored') {\n    readRequest._errorSteps(stream._storedError);\n  } else {\n    assert(stream._state === 'readable');\n    stream._readableStreamController[PullSteps](readRequest as ReadRequest<any>);\n  }\n}\n\nexport function ReadableStreamDefaultReaderRelease(reader: ReadableStreamDefaultReader) {\n  ReadableStreamReaderGenericRelease(reader);\n  const e = new TypeError('Reader was released');\n  ReadableStreamDefaultReaderErrorReadRequests(reader, e);\n}\n\nexport function ReadableStreamDefaultReaderErrorReadRequests(reader: ReadableStreamDefaultReader, e: any) {\n  const readRequests = reader._readRequests;\n  reader._readRequests = new SimpleQueue();\n  readRequests.forEach(readRequest => {\n    readRequest._errorSteps(e);\n  });\n}\n\n// Helper functions for the ReadableStreamDefaultReader.\n\nfunction defaultReaderBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n}\n", "/// <reference lib=\"es2018.asynciterable\" />\n\n/* eslint-disable @typescript-eslint/no-empty-function */\nexport const AsyncIteratorPrototype: AsyncIterable<any> =\n  Object.getPrototypeOf(Object.getPrototypeOf(async function* (): AsyncIterableIterator<any> {}).prototype);\n", "/// <reference lib=\"es2018.asynciterable\" />\n\nimport { ReadableStream } from '../readable-stream';\nimport {\n  AcquireReadableStreamDefaultReader,\n  ReadableStreamDefaultReader,\n  ReadableStreamDefaultReaderRead,\n  type ReadableStreamDefaultReadResult,\n  type ReadRequest\n} from './default-reader';\nimport { ReadableStreamReaderGenericCancel, ReadableStreamReaderGenericRelease } from './generic-reader';\nimport assert from '../../stub/assert';\nimport { AsyncIteratorPrototype } from '@@target/stub/async-iterator-prototype';\nimport { typeIsObject } from '../helpers/miscellaneous';\nimport {\n  newPromise,\n  promiseRejectedWith,\n  promiseResolvedWith,\n  queueMicrotask,\n  transformPromiseWith\n} from '../helpers/webidl';\n\n/**\n * An async iterator returned by {@link ReadableStream.values}.\n *\n * @public\n */\nexport interface ReadableStreamAsyncIterator<R> extends AsyncIterableIterator<R> {\n  next(): Promise<IteratorResult<R, undefined>>;\n\n  return(value?: any): Promise<IteratorResult<any>>;\n}\n\nexport class ReadableStreamAsyncIteratorImpl<R> {\n  private readonly _reader: ReadableStreamDefaultReader<R>;\n  private readonly _preventCancel: boolean;\n  private _ongoingPromise: Promise<ReadableStreamDefaultReadResult<R>> | undefined = undefined;\n  private _isFinished = false;\n\n  constructor(reader: ReadableStreamDefaultReader<R>, preventCancel: boolean) {\n    this._reader = reader;\n    this._preventCancel = preventCancel;\n  }\n\n  next(): Promise<ReadableStreamDefaultReadResult<R>> {\n    const nextSteps = () => this._nextSteps();\n    this._ongoingPromise = this._ongoingPromise ?\n      transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) :\n      nextSteps();\n    return this._ongoingPromise;\n  }\n\n  return(value: any): Promise<ReadableStreamDefaultReadResult<any>> {\n    const returnSteps = () => this._returnSteps(value);\n    return this._ongoingPromise ?\n      transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) :\n      returnSteps();\n  }\n\n  private _nextSteps(): Promise<ReadableStreamDefaultReadResult<R>> {\n    if (this._isFinished) {\n      return Promise.resolve({ value: undefined, done: true });\n    }\n\n    const reader = this._reader;\n    assert(reader._ownerReadableStream !== undefined);\n\n    let resolvePromise!: (result: ReadableStreamDefaultReadResult<R>) => void;\n    let rejectPromise!: (reason: any) => void;\n    const promise = newPromise<ReadableStreamDefaultReadResult<R>>((resolve, reject) => {\n      resolvePromise = resolve;\n      rejectPromise = reject;\n    });\n    const readRequest: ReadRequest<R> = {\n      _chunkSteps: chunk => {\n        this._ongoingPromise = undefined;\n        // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.\n        // FIXME Is this a bug in the specification, or in the test?\n        queueMicrotask(() => resolvePromise({ value: chunk, done: false }));\n      },\n      _closeSteps: () => {\n        this._ongoingPromise = undefined;\n        this._isFinished = true;\n        ReadableStreamReaderGenericRelease(reader);\n        resolvePromise({ value: undefined, done: true });\n      },\n      _errorSteps: reason => {\n        this._ongoingPromise = undefined;\n        this._isFinished = true;\n        ReadableStreamReaderGenericRelease(reader);\n        rejectPromise(reason);\n      }\n    };\n    ReadableStreamDefaultReaderRead(reader, readRequest);\n    return promise;\n  }\n\n  private _returnSteps(value: any): Promise<ReadableStreamDefaultReadResult<any>> {\n    if (this._isFinished) {\n      return Promise.resolve({ value, done: true });\n    }\n    this._isFinished = true;\n\n    const reader = this._reader;\n    assert(reader._ownerReadableStream !== undefined);\n    assert(reader._readRequests.length === 0);\n\n    if (!this._preventCancel) {\n      const result = ReadableStreamReaderGenericCancel(reader, value);\n      ReadableStreamReaderGenericRelease(reader);\n      return transformPromiseWith(result, () => ({ value, done: true }));\n    }\n\n    ReadableStreamReaderGenericRelease(reader);\n    return promiseResolvedWith({ value, done: true });\n  }\n}\n\ninterface ReadableStreamAsyncIteratorInstance<R> extends ReadableStreamAsyncIterator<R> {\n  /** @interal */\n  _asyncIteratorImpl: ReadableStreamAsyncIteratorImpl<R>;\n\n  next(): Promise<IteratorResult<R, undefined>>;\n\n  return(value?: any): Promise<IteratorResult<any>>;\n}\n\nconst ReadableStreamAsyncIteratorPrototype: ReadableStreamAsyncIteratorInstance<any> = {\n  next(this: ReadableStreamAsyncIteratorInstance<any>): Promise<ReadableStreamDefaultReadResult<any>> {\n    if (!IsReadableStreamAsyncIterator(this)) {\n      return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));\n    }\n    return this._asyncIteratorImpl.next();\n  },\n\n  return(this: ReadableStreamAsyncIteratorInstance<any>, value: any): Promise<ReadableStreamDefaultReadResult<any>> {\n    if (!IsReadableStreamAsyncIterator(this)) {\n      return promiseRejectedWith(streamAsyncIteratorBrandCheckException('return'));\n    }\n    return this._asyncIteratorImpl.return(value);\n  }\n} as any;\nObject.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);\n\n// Abstract operations for the ReadableStream.\n\nexport function AcquireReadableStreamAsyncIterator<R>(stream: ReadableStream<R>,\n                                                      preventCancel: boolean): ReadableStreamAsyncIterator<R> {\n  const reader = AcquireReadableStreamDefaultReader<R>(stream);\n  const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n  const iterator: ReadableStreamAsyncIteratorInstance<R> = Object.create(ReadableStreamAsyncIteratorPrototype);\n  iterator._asyncIteratorImpl = impl;\n  return iterator;\n}\n\nfunction IsReadableStreamAsyncIterator<R = any>(x: any): x is ReadableStreamAsyncIterator<R> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_asyncIteratorImpl')) {\n    return false;\n  }\n\n  try {\n    // noinspection SuspiciousTypeOfGuard\n    return (x as ReadableStreamAsyncIteratorInstance<any>)._asyncIteratorImpl instanceof\n      ReadableStreamAsyncIteratorImpl;\n  } catch {\n    return false;\n  }\n}\n\n// Helper functions for the ReadableStream.\n\nfunction streamAsyncIteratorBrandCheckException(name: string): TypeError {\n  return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);\n}\n", "/// <reference lib=\"es2015.core\" />\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\nconst NumberIsNaN: typeof Number.isNaN = Number.isNaN || function (x) {\n  // eslint-disable-next-line no-self-compare\n  return x !== x;\n};\n\nexport default NumberIsNaN;\n", "import { reflectCall } from 'lib/helpers/webidl';\nimport { typeIsObject } from '../helpers/miscellaneous';\nimport assert from '../../stub/assert';\n\ndeclare global {\n  interface ArrayBuffer {\n    readonly detached: boolean;\n\n    transfer(): ArrayBuffer;\n  }\n\n  function structuredClone<T>(value: T, options: { transfer: ArrayBuffer[] }): T;\n}\n\nexport function CreateArrayFromList<T extends any[]>(elements: T): T {\n  // We use arrays to represent lists, so this is basically a no-op.\n  // Do a slice though just in case we happen to depend on the unique-ness.\n  return elements.slice() as T;\n}\n\nexport function CopyDataBlockBytes(dest: ArrayBuffer,\n                                   destOffset: number,\n                                   src: ArrayBuffer,\n                                   srcOffset: number,\n                                   n: number) {\n  new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n}\n\nexport let TransferArrayBuffer = (O: ArrayBuffer): ArrayBuffer => {\n  if (typeof O.transfer === 'function') {\n    TransferArrayBuffer = buffer => buffer.transfer();\n  } else if (typeof structuredClone === 'function') {\n    TransferArrayBuffer = buffer => structuredClone(buffer, { transfer: [buffer] });\n  } else {\n    // Not implemented correctly\n    TransferArrayBuffer = buffer => buffer;\n  }\n  return TransferArrayBuffer(O);\n};\n\nexport function CanTransferArrayBuffer(O: ArrayBuffer): boolean {\n  return !IsDetachedBuffer(O);\n}\n\nexport let IsDetachedBuffer = (O: ArrayBuffer): boolean => {\n  if (typeof O.detached === 'boolean') {\n    IsDetachedBuffer = buffer => buffer.detached;\n  } else {\n    // Not implemented correctly\n    IsDetachedBuffer = buffer => buffer.byteLength === 0;\n  }\n  return IsDetachedBuffer(O);\n};\n\nexport function ArrayBufferSlice(buffer: ArrayBuffer, begin: number, end: number): ArrayBuffer {\n  // ArrayBuffer.prototype.slice is not available on IE10\n  // https://www.caniuse.com/mdn-javascript_builtins_arraybuffer_slice\n  if (buffer.slice) {\n    return buffer.slice(begin, end);\n  }\n  const length = end - begin;\n  const slice = new ArrayBuffer(length);\n  CopyDataBlockBytes(slice, 0, buffer, begin, length);\n  return slice;\n}\n\nexport type MethodName<T> = {\n  [P in keyof T]: T[P] extends Function | undefined ? P : never;\n}[keyof T];\n\nexport function GetMethod<T, K extends MethodName<T>>(receiver: T, prop: K): T[K] | undefined {\n  const func = receiver[prop];\n  if (func === undefined || func === null) {\n    return undefined;\n  }\n  if (typeof func !== 'function') {\n    throw new TypeError(`${String(prop)} is not a function`);\n  }\n  return func;\n}\n\nexport interface SyncIteratorRecord<T> {\n  iterator: Iterator<T>,\n  nextMethod: Iterator<T>['next'],\n  done: boolean;\n}\n\nexport interface AsyncIteratorRecord<T> {\n  iterator: AsyncIterator<T>,\n  nextMethod: AsyncIterator<T>['next'],\n  done: boolean;\n}\n\nexport type SyncOrAsyncIteratorRecord<T> = SyncIteratorRecord<T> | AsyncIteratorRecord<T>;\n\nexport function CreateAsyncFromSyncIterator<T>(syncIteratorRecord: SyncIteratorRecord<T>): AsyncIteratorRecord<T> {\n  // Instead of re-implementing CreateAsyncFromSyncIterator and %AsyncFromSyncIteratorPrototype%,\n  // we use yield* inside an async generator function to achieve the same result.\n\n  // Wrap the sync iterator inside a sync iterable, so we can use it with yield*.\n  const syncIterable = {\n    [Symbol.iterator]: () => syncIteratorRecord.iterator\n  };\n  // Create an async generator function and immediately invoke it.\n  const asyncIterator = (async function* () {\n    return yield* syncIterable;\n  }());\n  // Return as an async iterator record.\n  const nextMethod = asyncIterator.next;\n  return { iterator: asyncIterator, nextMethod, done: false };\n}\n\n// Aligns with core-js/modules/es.symbol.async-iterator.js\nexport const SymbolAsyncIterator: (typeof Symbol)['asyncIterator'] =\n  Symbol.asyncIterator ??\n  Symbol.for?.('Symbol.asyncIterator') ??\n  '@@asyncIterator';\n\nexport type SyncOrAsyncIterable<T> = Iterable<T> | AsyncIterable<T>;\nexport type SyncOrAsyncIteratorMethod<T> = () => (Iterator<T> | AsyncIterator<T>);\n\nfunction GetIterator<T>(\n  obj: SyncOrAsyncIterable<T>,\n  hint: 'async',\n  method?: SyncOrAsyncIteratorMethod<T>\n): AsyncIteratorRecord<T>;\nfunction GetIterator<T>(\n  obj: Iterable<T>,\n  hint: 'sync',\n  method?: SyncOrAsyncIteratorMethod<T>\n): SyncIteratorRecord<T>;\nfunction GetIterator<T>(\n  obj: SyncOrAsyncIterable<T>,\n  hint = 'sync',\n  method?: SyncOrAsyncIteratorMethod<T>\n): SyncOrAsyncIteratorRecord<T> {\n  assert(hint === 'sync' || hint === 'async');\n  if (method === undefined) {\n    if (hint === 'async') {\n      method = GetMethod(obj as AsyncIterable<T>, SymbolAsyncIterator);\n      if (method === undefined) {\n        const syncMethod = GetMethod(obj as Iterable<T>, Symbol.iterator);\n        const syncIteratorRecord = GetIterator(obj as Iterable<T>, 'sync', syncMethod);\n        return CreateAsyncFromSyncIterator(syncIteratorRecord);\n      }\n    } else {\n      method = GetMethod(obj as Iterable<T>, Symbol.iterator);\n    }\n  }\n  if (method === undefined) {\n    throw new TypeError('The object is not iterable');\n  }\n  const iterator = reflectCall(method, obj, []);\n  if (!typeIsObject(iterator)) {\n    throw new TypeError('The iterator method must return an object');\n  }\n  const nextMethod = iterator.next;\n  return { iterator, nextMethod, done: false } as SyncOrAsyncIteratorRecord<T>;\n}\n\nexport { GetIterator };\n\nexport function IteratorNext<T>(iteratorRecord: AsyncIteratorRecord<T>): Promise<IteratorResult<T>> {\n  const result = reflectCall(iteratorRecord.nextMethod, iteratorRecord.iterator, []);\n  if (!typeIsObject(result)) {\n    throw new TypeError('The iterator.next() method must return an object');\n  }\n  return result;\n}\n\nexport function IteratorComplete<TReturn>(\n  iterResult: IteratorResult<unknown, TReturn>\n): iterResult is IteratorReturnResult<TReturn> {\n  assert(typeIsObject(iterResult));\n  return Boolean(iterResult.done);\n}\n\nexport function IteratorValue<T>(iterResult: IteratorYieldResult<T>): T {\n  assert(typeIsObject(iterResult));\n  return iterResult.value;\n}\n", "import NumberIsNaN from '../../stub/number-isnan';\nimport { ArrayBufferSlice } from './ecmascript';\nimport type { NonShared } from '../helpers/array-buffer-view';\n\nexport function IsNonNegativeNumber(v: number): boolean {\n  if (typeof v !== 'number') {\n    return false;\n  }\n\n  if (NumberIsNaN(v)) {\n    return false;\n  }\n\n  if (v < 0) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function CloneAsUint8Array(O: NonShared<ArrayBufferView>): NonShared<Uint8Array> {\n  const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);\n  return new Uint8Array(buffer) as NonShared<Uint8Array>;\n}\n", "import assert from '../../stub/assert';\nimport { SimpleQueue } from '../simple-queue';\nimport { IsNonNegativeNumber } from './miscellaneous';\n\nexport interface QueueContainer<T> {\n  _queue: SimpleQueue<T>;\n  _queueTotalSize: number;\n}\n\nexport interface QueuePair<T> {\n  value: T;\n  size: number;\n}\n\nexport function DequeueValue<T>(container: QueueContainer<QueuePair<T>>): T {\n  assert('_queue' in container && '_queueTotalSize' in container);\n  assert(container._queue.length > 0);\n\n  const pair = container._queue.shift()!;\n  container._queueTotalSize -= pair.size;\n  if (container._queueTotalSize < 0) {\n    container._queueTotalSize = 0;\n  }\n\n  return pair.value;\n}\n\nexport function EnqueueValueWithSize<T>(container: QueueContainer<QueuePair<T>>, value: T, size: number) {\n  assert('_queue' in container && '_queueTotalSize' in container);\n\n  if (!IsNonNegativeNumber(size) || size === Infinity) {\n    throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\n  }\n\n  container._queue.push({ value, size });\n  container._queueTotalSize += size;\n}\n\nexport function PeekQueueValue<T>(container: QueueContainer<QueuePair<T>>): T {\n  assert('_queue' in container && '_queueTotalSize' in container);\n  assert(container._queue.length > 0);\n\n  const pair = container._queue.peek();\n  return pair.value;\n}\n\nexport function ResetQueue<T>(container: QueueContainer<T>) {\n  assert('_queue' in container && '_queueTotalSize' in container);\n\n  container._queue = new SimpleQueue<T>();\n  container._queueTotalSize = 0;\n}\n", "export type TypedArray =\n  | Int8Array\n  | Uint8Array\n  | Uint8ClampedArray\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Float32Array\n  | Float64Array;\n\nexport type NonShared<T extends ArrayBufferView> = T & {\n  buffer: ArrayBuffer;\n}\n\nexport interface ArrayBufferViewConstructor<T extends ArrayBufferView = ArrayBufferView> {\n  new(buffer: ArrayBuffer, byteOffset: number, length?: number): T;\n\n  readonly prototype: T;\n}\n\nexport interface TypedArrayConstructor<T extends TypedArray = TypedArray> extends ArrayBufferViewConstructor<T> {\n  readonly BYTES_PER_ELEMENT: number;\n}\n\nexport type DataViewConstructor = ArrayBufferViewConstructor<DataView>;\n\nfunction isDataViewConstructor(ctor: Function): ctor is DataViewConstructor {\n  return ctor === DataView;\n}\n\nexport function isDataView(view: ArrayBufferView): view is DataView {\n  return isDataViewConstructor(view.constructor);\n}\n\nexport function arrayBufferViewElementSize<T extends ArrayBufferView>(ctor: ArrayBufferViewConstructor<T>): number {\n  if (isDataViewConstructor(ctor)) {\n    return 1;\n  }\n  return (ctor as unknown as TypedArrayConstructor).BYTES_PER_ELEMENT;\n}\n", "import assert from '../../stub/assert';\nimport { SimpleQueue } from '../simple-queue';\nimport { ResetQueue } from '../abstract-ops/queue-with-sizes';\nimport {\n  IsReadableStreamDefaultReader,\n  ReadableStreamAddReadRequest,\n  ReadableStreamFulfillReadRequest,\n  ReadableStreamGetNumReadRequests,\n  ReadableStreamHasDefaultReader,\n  type ReadRequest\n} from './default-reader';\nimport {\n  ReadableStreamAddReadIntoRequest,\n  ReadableStreamFulfillReadIntoRequest,\n  ReadableStreamGetNumReadIntoRequests,\n  ReadableStreamHasBYOBReader,\n  type ReadIntoRequest\n} from './byob-reader';\nimport NumberIsInteger from '../../stub/number-isinteger';\nimport {\n  IsReadableStreamLocked,\n  type ReadableByteStream,\n  ReadableStreamClose,\n  ReadableStreamError\n} from '../readable-stream';\nimport type { ValidatedUnderlyingByteSource } from './underlying-source';\nimport { setFunctionName, typeIsObject } from '../helpers/miscellaneous';\nimport {\n  ArrayBufferSlice,\n  CanTransferArrayBuffer,\n  CopyDataBlockBytes,\n  IsDetachedBuffer,\n  TransferArrayBuffer\n} from '../abstract-ops/ecmascript';\nimport { CancelSteps, PullSteps, ReleaseSteps } from '../abstract-ops/internal-methods';\nimport { promiseResolvedWith, uponPromise } from '../helpers/webidl';\nimport { assertRequiredArgument, convertUnsignedLongLongWithEnforceRange } from '../validators/basic';\nimport {\n  type ArrayBufferViewConstructor,\n  arrayBufferViewElementSize,\n  type NonShared,\n  type TypedArrayConstructor\n} from '../helpers/array-buffer-view';\n\n/**\n * A pull-into request in a {@link ReadableByteStreamController}.\n *\n * @public\n */\nexport class ReadableStreamBYOBRequest {\n  /** @internal */\n  _associatedReadableByteStreamController!: ReadableByteStreamController;\n  /** @internal */\n  _view!: NonShared<ArrayBufferView> | null;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.\n   */\n  get view(): ArrayBufferView | null {\n    if (!IsReadableStreamBYOBRequest(this)) {\n      throw byobRequestBrandCheckException('view');\n    }\n\n    return this._view;\n  }\n\n  /**\n   * Indicates to the associated readable byte stream that `bytesWritten` bytes were written into\n   * {@link ReadableStreamBYOBRequest.view | view}, causing the result be surfaced to the consumer.\n   *\n   * After this method is called, {@link ReadableStreamBYOBRequest.view | view} will be transferred and no longer\n   * modifiable.\n   */\n  respond(bytesWritten: number): void;\n  respond(bytesWritten: number | undefined): void {\n    if (!IsReadableStreamBYOBRequest(this)) {\n      throw byobRequestBrandCheckException('respond');\n    }\n    assertRequiredArgument(bytesWritten, 1, 'respond');\n    bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, 'First parameter');\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (IsDetachedBuffer(this._view!.buffer)) {\n      throw new TypeError(`The BYOB request's buffer has been detached and so cannot be used as a response`);\n    }\n\n    assert(this._view!.byteLength > 0);\n    assert(this._view!.buffer.byteLength > 0);\n\n    ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n  }\n\n  /**\n   * Indicates to the associated readable byte stream that instead of writing into\n   * {@link ReadableStreamBYOBRequest.view | view}, the underlying byte source is providing a new `ArrayBufferView`,\n   * which will be given to the consumer of the readable byte stream.\n   *\n   * After this method is called, `view` will be transferred and no longer modifiable.\n   */\n  respondWithNewView(view: ArrayBufferView): void;\n  respondWithNewView(view: NonShared<ArrayBufferView>): void {\n    if (!IsReadableStreamBYOBRequest(this)) {\n      throw byobRequestBrandCheckException('respondWithNewView');\n    }\n    assertRequiredArgument(view, 1, 'respondWithNewView');\n\n    if (!ArrayBuffer.isView(view)) {\n      throw new TypeError('You can only respond with array buffer views');\n    }\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (IsDetachedBuffer(view.buffer)) {\n      throw new TypeError('The given view\\'s buffer has been detached and so cannot be used as a response');\n    }\n\n    ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n  }\n}\n\nObject.defineProperties(ReadableStreamBYOBRequest.prototype, {\n  respond: { enumerable: true },\n  respondWithNewView: { enumerable: true },\n  view: { enumerable: true }\n});\nsetFunctionName(ReadableStreamBYOBRequest.prototype.respond, 'respond');\nsetFunctionName(ReadableStreamBYOBRequest.prototype.respondWithNewView, 'respondWithNewView');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStreamBYOBRequest.prototype, Symbol.toStringTag, {\n    value: 'ReadableStreamBYOBRequest',\n    configurable: true\n  });\n}\n\ninterface ByteQueueElement {\n  buffer: ArrayBuffer;\n  byteOffset: number;\n  byteLength: number;\n}\n\ntype PullIntoDescriptor<T extends NonShared<ArrayBufferView> = NonShared<ArrayBufferView>> =\n  DefaultPullIntoDescriptor\n  | BYOBPullIntoDescriptor<T>;\n\ninterface DefaultPullIntoDescriptor {\n  buffer: ArrayBuffer;\n  bufferByteLength: number;\n  byteOffset: number;\n  byteLength: number;\n  bytesFilled: number;\n  minimumFill: number;\n  elementSize: number;\n  viewConstructor: TypedArrayConstructor<Uint8Array>;\n  readerType: 'default' | 'none';\n}\n\ninterface BYOBPullIntoDescriptor<T extends NonShared<ArrayBufferView> = NonShared<ArrayBufferView>> {\n  buffer: ArrayBuffer;\n  bufferByteLength: number;\n  byteOffset: number;\n  byteLength: number;\n  bytesFilled: number;\n  minimumFill: number;\n  elementSize: number;\n  viewConstructor: ArrayBufferViewConstructor<T>;\n  readerType: 'byob' | 'none';\n}\n\n/**\n * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.\n *\n * @public\n */\nexport class ReadableByteStreamController {\n  /** @internal */\n  _controlledReadableByteStream!: ReadableByteStream;\n  /** @internal */\n  _queue!: SimpleQueue<ByteQueueElement>;\n  /** @internal */\n  _queueTotalSize!: number;\n  /** @internal */\n  _started!: boolean;\n  /** @internal */\n  _closeRequested!: boolean;\n  /** @internal */\n  _pullAgain!: boolean;\n  /** @internal */\n  _pulling !: boolean;\n  /** @internal */\n  _strategyHWM!: number;\n  /** @internal */\n  _pullAlgorithm!: () => Promise<void>;\n  /** @internal */\n  _cancelAlgorithm!: (reason: any) => Promise<void>;\n  /** @internal */\n  _autoAllocateChunkSize: number | undefined;\n  /** @internal */\n  _byobRequest: ReadableStreamBYOBRequest | null;\n  /** @internal */\n  _pendingPullIntos!: SimpleQueue<PullIntoDescriptor>;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * Returns the current BYOB pull request, or `null` if there isn't one.\n   */\n  get byobRequest(): ReadableStreamBYOBRequest | null {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('byobRequest');\n    }\n\n    return ReadableByteStreamControllerGetBYOBRequest(this);\n  }\n\n  /**\n   * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n   * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.\n   */\n  get desiredSize(): number | null {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('desiredSize');\n    }\n\n    return ReadableByteStreamControllerGetDesiredSize(this);\n  }\n\n  /**\n   * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n   * the stream, but once those are read, the stream will become closed.\n   */\n  close(): void {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('close');\n    }\n\n    if (this._closeRequested) {\n      throw new TypeError('The stream has already been closed; do not close it again!');\n    }\n\n    const state = this._controlledReadableByteStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n    }\n\n    ReadableByteStreamControllerClose(this);\n  }\n\n  /**\n   * Enqueues the given chunk chunk in the controlled readable stream.\n   * The chunk has to be an `ArrayBufferView` instance, or else a `TypeError` will be thrown.\n   */\n  enqueue(chunk: ArrayBufferView): void;\n  enqueue(chunk: NonShared<ArrayBufferView>): void {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('enqueue');\n    }\n\n    assertRequiredArgument(chunk, 1, 'enqueue');\n    if (!ArrayBuffer.isView(chunk)) {\n      throw new TypeError('chunk must be an array buffer view');\n    }\n    if (chunk.byteLength === 0) {\n      throw new TypeError('chunk must have non-zero byteLength');\n    }\n    if (chunk.buffer.byteLength === 0) {\n      throw new TypeError(`chunk's buffer must have non-zero byteLength`);\n    }\n\n    if (this._closeRequested) {\n      throw new TypeError('stream is closed or draining');\n    }\n\n    const state = this._controlledReadableByteStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n    }\n\n    ReadableByteStreamControllerEnqueue(this, chunk);\n  }\n\n  /**\n   * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n   */\n  error(e: any = undefined): void {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('error');\n    }\n\n    ReadableByteStreamControllerError(this, e);\n  }\n\n  /** @internal */\n  [CancelSteps](reason: any): Promise<void> {\n    ReadableByteStreamControllerClearPendingPullIntos(this);\n\n    ResetQueue(this);\n\n    const result = this._cancelAlgorithm(reason);\n    ReadableByteStreamControllerClearAlgorithms(this);\n    return result;\n  }\n\n  /** @internal */\n  [PullSteps](readRequest: ReadRequest<NonShared<Uint8Array>>): void {\n    const stream = this._controlledReadableByteStream;\n    assert(ReadableStreamHasDefaultReader(stream));\n\n    if (this._queueTotalSize > 0) {\n      assert(ReadableStreamGetNumReadRequests(stream) === 0);\n\n      ReadableByteStreamControllerFillReadRequestFromQueue(this, readRequest);\n      return;\n    }\n\n    const autoAllocateChunkSize = this._autoAllocateChunkSize;\n    if (autoAllocateChunkSize !== undefined) {\n      let buffer: ArrayBuffer;\n      try {\n        buffer = new ArrayBuffer(autoAllocateChunkSize);\n      } catch (bufferE) {\n        readRequest._errorSteps(bufferE);\n        return;\n      }\n\n      const pullIntoDescriptor: DefaultPullIntoDescriptor = {\n        buffer,\n        bufferByteLength: autoAllocateChunkSize,\n        byteOffset: 0,\n        byteLength: autoAllocateChunkSize,\n        bytesFilled: 0,\n        minimumFill: 1,\n        elementSize: 1,\n        viewConstructor: Uint8Array,\n        readerType: 'default'\n      };\n\n      this._pendingPullIntos.push(pullIntoDescriptor);\n    }\n\n    ReadableStreamAddReadRequest(stream, readRequest);\n    ReadableByteStreamControllerCallPullIfNeeded(this);\n  }\n\n  /** @internal */\n  [ReleaseSteps](): void {\n    if (this._pendingPullIntos.length > 0) {\n      const firstPullInto = this._pendingPullIntos.peek();\n      firstPullInto.readerType = 'none';\n\n      this._pendingPullIntos = new SimpleQueue();\n      this._pendingPullIntos.push(firstPullInto);\n    }\n  }\n}\n\nObject.defineProperties(ReadableByteStreamController.prototype, {\n  close: { enumerable: true },\n  enqueue: { enumerable: true },\n  error: { enumerable: true },\n  byobRequest: { enumerable: true },\n  desiredSize: { enumerable: true }\n});\nsetFunctionName(ReadableByteStreamController.prototype.close, 'close');\nsetFunctionName(ReadableByteStreamController.prototype.enqueue, 'enqueue');\nsetFunctionName(ReadableByteStreamController.prototype.error, 'error');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableByteStreamController.prototype, Symbol.toStringTag, {\n    value: 'ReadableByteStreamController',\n    configurable: true\n  });\n}\n\n// Abstract operations for the ReadableByteStreamController.\n\nexport function IsReadableByteStreamController(x: any): x is ReadableByteStreamController {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\n    return false;\n  }\n\n  return x instanceof ReadableByteStreamController;\n}\n\nfunction IsReadableStreamBYOBRequest(x: any): x is ReadableStreamBYOBRequest {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\n    return false;\n  }\n\n  return x instanceof ReadableStreamBYOBRequest;\n}\n\nfunction ReadableByteStreamControllerCallPullIfNeeded(controller: ReadableByteStreamController): void {\n  const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n  if (!shouldPull) {\n    return;\n  }\n\n  if (controller._pulling) {\n    controller._pullAgain = true;\n    return;\n  }\n\n  assert(!controller._pullAgain);\n\n  controller._pulling = true;\n\n  // TODO: Test controller argument\n  const pullPromise = controller._pullAlgorithm();\n  uponPromise(\n    pullPromise,\n    () => {\n      controller._pulling = false;\n\n      if (controller._pullAgain) {\n        controller._pullAgain = false;\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n      }\n\n      return null;\n    },\n    e => {\n      ReadableByteStreamControllerError(controller, e);\n      return null;\n    }\n  );\n}\n\nfunction ReadableByteStreamControllerClearPendingPullIntos(controller: ReadableByteStreamController) {\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  controller._pendingPullIntos = new SimpleQueue();\n}\n\nfunction ReadableByteStreamControllerCommitPullIntoDescriptor<T extends NonShared<ArrayBufferView>>(\n  stream: ReadableByteStream,\n  pullIntoDescriptor: PullIntoDescriptor<T>\n) {\n  assert(stream._state !== 'errored');\n  assert(pullIntoDescriptor.readerType !== 'none');\n\n  let done = false;\n  if (stream._state === 'closed') {\n    assert(pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize === 0);\n    done = true;\n  }\n\n  const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor<T>(pullIntoDescriptor);\n  if (pullIntoDescriptor.readerType === 'default') {\n    ReadableStreamFulfillReadRequest(stream, filledView as unknown as NonShared<Uint8Array>, done);\n  } else {\n    assert(pullIntoDescriptor.readerType === 'byob');\n    ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n  }\n}\n\nfunction ReadableByteStreamControllerConvertPullIntoDescriptor<T extends NonShared<ArrayBufferView>>(\n  pullIntoDescriptor: PullIntoDescriptor<T>\n): T {\n  const bytesFilled = pullIntoDescriptor.bytesFilled;\n  const elementSize = pullIntoDescriptor.elementSize;\n\n  assert(bytesFilled <= pullIntoDescriptor.byteLength);\n  assert(bytesFilled % elementSize === 0);\n\n  return new pullIntoDescriptor.viewConstructor(\n    pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize) as T;\n}\n\nfunction ReadableByteStreamControllerEnqueueChunkToQueue(controller: ReadableByteStreamController,\n                                                         buffer: ArrayBuffer,\n                                                         byteOffset: number,\n                                                         byteLength: number) {\n  controller._queue.push({ buffer, byteOffset, byteLength });\n  controller._queueTotalSize += byteLength;\n}\n\nfunction ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller: ReadableByteStreamController,\n                                                               buffer: ArrayBuffer,\n                                                               byteOffset: number,\n                                                               byteLength: number) {\n  let clonedChunk;\n  try {\n    clonedChunk = ArrayBufferSlice(buffer, byteOffset, byteOffset + byteLength);\n  } catch (cloneE) {\n    ReadableByteStreamControllerError(controller, cloneE);\n    throw cloneE;\n  }\n  ReadableByteStreamControllerEnqueueChunkToQueue(controller, clonedChunk, 0, byteLength);\n}\n\nfunction ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller: ReadableByteStreamController,\n                                                                    firstDescriptor: PullIntoDescriptor) {\n  assert(firstDescriptor.readerType === 'none');\n  if (firstDescriptor.bytesFilled > 0) {\n    ReadableByteStreamControllerEnqueueClonedChunkToQueue(\n      controller,\n      firstDescriptor.buffer,\n      firstDescriptor.byteOffset,\n      firstDescriptor.bytesFilled\n    );\n  }\n  ReadableByteStreamControllerShiftPendingPullInto(controller);\n}\n\nfunction ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller: ReadableByteStreamController,\n                                                                     pullIntoDescriptor: PullIntoDescriptor) {\n  const maxBytesToCopy = Math.min(controller._queueTotalSize,\n                                  pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n  const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n\n  let totalBytesToCopyRemaining = maxBytesToCopy;\n  let ready = false;\n  assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill);\n  const remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;\n  const maxAlignedBytes = maxBytesFilled - remainderBytes;\n  // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n  // of the queue, so the underlying source can keep filling it.\n  if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {\n    totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n    ready = true;\n  }\n\n  const queue = controller._queue;\n\n  while (totalBytesToCopyRemaining > 0) {\n    const headOfQueue = queue.peek();\n\n    const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n\n    const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n\n    if (headOfQueue.byteLength === bytesToCopy) {\n      queue.shift();\n    } else {\n      headOfQueue.byteOffset += bytesToCopy;\n      headOfQueue.byteLength -= bytesToCopy;\n    }\n    controller._queueTotalSize -= bytesToCopy;\n\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n\n    totalBytesToCopyRemaining -= bytesToCopy;\n  }\n\n  if (!ready) {\n    assert(controller._queueTotalSize === 0);\n    assert(pullIntoDescriptor.bytesFilled > 0);\n    assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill);\n  }\n\n  return ready;\n}\n\nfunction ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller: ReadableByteStreamController,\n                                                                size: number,\n                                                                pullIntoDescriptor: PullIntoDescriptor) {\n  assert(controller._pendingPullIntos.length === 0 || controller._pendingPullIntos.peek() === pullIntoDescriptor);\n  assert(controller._byobRequest === null);\n  pullIntoDescriptor.bytesFilled += size;\n}\n\nfunction ReadableByteStreamControllerHandleQueueDrain(controller: ReadableByteStreamController) {\n  assert(controller._controlledReadableByteStream._state === 'readable');\n\n  if (controller._queueTotalSize === 0 && controller._closeRequested) {\n    ReadableByteStreamControllerClearAlgorithms(controller);\n    ReadableStreamClose(controller._controlledReadableByteStream);\n  } else {\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n  }\n}\n\nfunction ReadableByteStreamControllerInvalidateBYOBRequest(controller: ReadableByteStreamController) {\n  if (controller._byobRequest === null) {\n    return;\n  }\n\n  controller._byobRequest._associatedReadableByteStreamController = undefined!;\n  controller._byobRequest._view = null!;\n  controller._byobRequest = null;\n}\n\nfunction ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller: ReadableByteStreamController) {\n  assert(!controller._closeRequested);\n\n  while (controller._pendingPullIntos.length > 0) {\n    if (controller._queueTotalSize === 0) {\n      return;\n    }\n\n    const pullIntoDescriptor = controller._pendingPullIntos.peek();\n    assert(pullIntoDescriptor.readerType !== 'none');\n\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n      ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n      ReadableByteStreamControllerCommitPullIntoDescriptor(\n        controller._controlledReadableByteStream,\n        pullIntoDescriptor\n      );\n    }\n  }\n}\n\nfunction ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller: ReadableByteStreamController) {\n  const reader = controller._controlledReadableByteStream._reader;\n  assert(IsReadableStreamDefaultReader(reader));\n  while (reader._readRequests.length > 0) {\n    if (controller._queueTotalSize === 0) {\n      return;\n    }\n    const readRequest = reader._readRequests.shift();\n    ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest);\n  }\n}\n\nexport function ReadableByteStreamControllerPullInto<T extends NonShared<ArrayBufferView>>(\n  controller: ReadableByteStreamController,\n  view: T,\n  min: number,\n  readIntoRequest: ReadIntoRequest<T>\n): void {\n  const stream = controller._controlledReadableByteStream;\n\n  const ctor = view.constructor as ArrayBufferViewConstructor<T>;\n  const elementSize = arrayBufferViewElementSize(ctor);\n\n  const { byteOffset, byteLength } = view;\n\n  const minimumFill = min * elementSize;\n  assert(minimumFill >= elementSize && minimumFill <= byteLength);\n  assert(minimumFill % elementSize === 0);\n\n  let buffer: ArrayBuffer;\n  try {\n    buffer = TransferArrayBuffer(view.buffer);\n  } catch (e) {\n    readIntoRequest._errorSteps(e);\n    return;\n  }\n\n  const pullIntoDescriptor: BYOBPullIntoDescriptor<T> = {\n    buffer,\n    bufferByteLength: buffer.byteLength,\n    byteOffset,\n    byteLength,\n    bytesFilled: 0,\n    minimumFill,\n    elementSize,\n    viewConstructor: ctor,\n    readerType: 'byob'\n  };\n\n  if (controller._pendingPullIntos.length > 0) {\n    controller._pendingPullIntos.push(pullIntoDescriptor);\n\n    // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n    // - No change happens on desiredSize\n    // - The source has already been notified of that there's at least 1 pending read(view)\n\n    ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n    return;\n  }\n\n  if (stream._state === 'closed') {\n    const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n    readIntoRequest._closeSteps(emptyView);\n    return;\n  }\n\n  if (controller._queueTotalSize > 0) {\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n      const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor<T>(pullIntoDescriptor);\n\n      ReadableByteStreamControllerHandleQueueDrain(controller);\n\n      readIntoRequest._chunkSteps(filledView);\n      return;\n    }\n\n    if (controller._closeRequested) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n\n      readIntoRequest._errorSteps(e);\n      return;\n    }\n  }\n\n  controller._pendingPullIntos.push(pullIntoDescriptor);\n\n  ReadableStreamAddReadIntoRequest<T>(stream, readIntoRequest);\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction ReadableByteStreamControllerRespondInClosedState(controller: ReadableByteStreamController,\n                                                          firstDescriptor: PullIntoDescriptor) {\n  assert(firstDescriptor.bytesFilled % firstDescriptor.elementSize === 0);\n\n  if (firstDescriptor.readerType === 'none') {\n    ReadableByteStreamControllerShiftPendingPullInto(controller);\n  }\n\n  const stream = controller._controlledReadableByteStream;\n  if (ReadableStreamHasBYOBReader(stream)) {\n    while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n      const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n      ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n    }\n  }\n}\n\nfunction ReadableByteStreamControllerRespondInReadableState(controller: ReadableByteStreamController,\n                                                            bytesWritten: number,\n                                                            pullIntoDescriptor: PullIntoDescriptor) {\n  assert(pullIntoDescriptor.bytesFilled + bytesWritten <= pullIntoDescriptor.byteLength);\n\n  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n\n  if (pullIntoDescriptor.readerType === 'none') {\n    ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, pullIntoDescriptor);\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n    return;\n  }\n\n  if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {\n    // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n    // of the queue, so the underlying source can keep filling it.\n    return;\n  }\n\n  ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n  const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n  if (remainderSize > 0) {\n    const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    ReadableByteStreamControllerEnqueueClonedChunkToQueue(\n      controller,\n      pullIntoDescriptor.buffer,\n      end - remainderSize,\n      remainderSize\n    );\n  }\n\n  pullIntoDescriptor.bytesFilled -= remainderSize;\n  ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n\n  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n}\n\nfunction ReadableByteStreamControllerRespondInternal(controller: ReadableByteStreamController, bytesWritten: number) {\n  const firstDescriptor = controller._pendingPullIntos.peek();\n  assert(CanTransferArrayBuffer(firstDescriptor.buffer));\n\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n\n  const state = controller._controlledReadableByteStream._state;\n  if (state === 'closed') {\n    assert(bytesWritten === 0);\n    ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n  } else {\n    assert(state === 'readable');\n    assert(bytesWritten > 0);\n    ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n  }\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction ReadableByteStreamControllerShiftPendingPullInto(\n  controller: ReadableByteStreamController\n): PullIntoDescriptor {\n  assert(controller._byobRequest === null);\n  const descriptor = controller._pendingPullIntos.shift()!;\n  return descriptor;\n}\n\nfunction ReadableByteStreamControllerShouldCallPull(controller: ReadableByteStreamController): boolean {\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state !== 'readable') {\n    return false;\n  }\n\n  if (controller._closeRequested) {\n    return false;\n  }\n\n  if (!controller._started) {\n    return false;\n  }\n\n  if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n    return true;\n  }\n\n  const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n  assert(desiredSize !== null);\n  if (desiredSize! > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction ReadableByteStreamControllerClearAlgorithms(controller: ReadableByteStreamController) {\n  controller._pullAlgorithm = undefined!;\n  controller._cancelAlgorithm = undefined!;\n}\n\n// A client of ReadableByteStreamController may use these functions directly to bypass state check.\n\nexport function ReadableByteStreamControllerClose(controller: ReadableByteStreamController) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (controller._closeRequested || stream._state !== 'readable') {\n    return;\n  }\n\n  if (controller._queueTotalSize > 0) {\n    controller._closeRequested = true;\n\n    return;\n  }\n\n  if (controller._pendingPullIntos.length > 0) {\n    const firstPendingPullInto = controller._pendingPullIntos.peek();\n    if (firstPendingPullInto.bytesFilled % firstPendingPullInto.elementSize !== 0) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n\n      throw e;\n    }\n  }\n\n  ReadableByteStreamControllerClearAlgorithms(controller);\n  ReadableStreamClose(stream);\n}\n\nexport function ReadableByteStreamControllerEnqueue(\n  controller: ReadableByteStreamController,\n  chunk: NonShared<ArrayBufferView>\n) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (controller._closeRequested || stream._state !== 'readable') {\n    return;\n  }\n\n  const { buffer, byteOffset, byteLength } = chunk;\n  if (IsDetachedBuffer(buffer)) {\n    throw new TypeError('chunk\\'s buffer is detached and so cannot be enqueued');\n  }\n  const transferredBuffer = TransferArrayBuffer(buffer);\n\n  if (controller._pendingPullIntos.length > 0) {\n    const firstPendingPullInto = controller._pendingPullIntos.peek();\n    if (IsDetachedBuffer(firstPendingPullInto.buffer)) {\n      throw new TypeError(\n        'The BYOB request\\'s buffer has been detached and so cannot be filled with an enqueued chunk'\n      );\n    }\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n    firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);\n    if (firstPendingPullInto.readerType === 'none') {\n      ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstPendingPullInto);\n    }\n  }\n\n  if (ReadableStreamHasDefaultReader(stream)) {\n    ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller);\n    if (ReadableStreamGetNumReadRequests(stream) === 0) {\n      assert(controller._pendingPullIntos.length === 0);\n      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    } else {\n      assert(controller._queue.length === 0);\n      if (controller._pendingPullIntos.length > 0) {\n        assert(controller._pendingPullIntos.peek().readerType === 'default');\n        ReadableByteStreamControllerShiftPendingPullInto(controller);\n      }\n      const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n      ReadableStreamFulfillReadRequest(stream, transferredView as NonShared<Uint8Array>, false);\n    }\n  } else if (ReadableStreamHasBYOBReader(stream)) {\n    // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n  } else {\n    assert(!IsReadableStreamLocked(stream));\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n  }\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nexport function ReadableByteStreamControllerError(controller: ReadableByteStreamController, e: any) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state !== 'readable') {\n    return;\n  }\n\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\n\n  ResetQueue(controller);\n  ReadableByteStreamControllerClearAlgorithms(controller);\n  ReadableStreamError(stream, e);\n}\n\nexport function ReadableByteStreamControllerFillReadRequestFromQueue(\n  controller: ReadableByteStreamController,\n  readRequest: ReadRequest<NonShared<Uint8Array>>\n) {\n  assert(controller._queueTotalSize > 0);\n\n  const entry = controller._queue.shift();\n  controller._queueTotalSize -= entry.byteLength;\n\n  ReadableByteStreamControllerHandleQueueDrain(controller);\n\n  const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n  readRequest._chunkSteps(view as NonShared<Uint8Array>);\n}\n\nexport function ReadableByteStreamControllerGetBYOBRequest(\n  controller: ReadableByteStreamController\n): ReadableStreamBYOBRequest | null {\n  if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {\n    const firstDescriptor = controller._pendingPullIntos.peek();\n    const view = new Uint8Array(firstDescriptor.buffer,\n                                firstDescriptor.byteOffset + firstDescriptor.bytesFilled,\n                                firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n\n    const byobRequest: ReadableStreamBYOBRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n    SetUpReadableStreamBYOBRequest(byobRequest, controller, view as NonShared<Uint8Array>);\n    controller._byobRequest = byobRequest;\n  }\n  return controller._byobRequest;\n}\n\nfunction ReadableByteStreamControllerGetDesiredSize(controller: ReadableByteStreamController): number | null {\n  const state = controller._controlledReadableByteStream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\nexport function ReadableByteStreamControllerRespond(controller: ReadableByteStreamController, bytesWritten: number) {\n  assert(controller._pendingPullIntos.length > 0);\n\n  const firstDescriptor = controller._pendingPullIntos.peek();\n  const state = controller._controlledReadableByteStream._state;\n\n  if (state === 'closed') {\n    if (bytesWritten !== 0) {\n      throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n    }\n  } else {\n    assert(state === 'readable');\n    if (bytesWritten === 0) {\n      throw new TypeError('bytesWritten must be greater than 0 when calling respond() on a readable stream');\n    }\n    if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {\n      throw new RangeError('bytesWritten out of range');\n    }\n  }\n\n  firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n\n  ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n}\n\nexport function ReadableByteStreamControllerRespondWithNewView(controller: ReadableByteStreamController,\n                                                               view: NonShared<ArrayBufferView>) {\n  assert(controller._pendingPullIntos.length > 0);\n  assert(!IsDetachedBuffer(view.buffer));\n\n  const firstDescriptor = controller._pendingPullIntos.peek();\n  const state = controller._controlledReadableByteStream._state;\n\n  if (state === 'closed') {\n    if (view.byteLength !== 0) {\n      throw new TypeError('The view\\'s length must be 0 when calling respondWithNewView() on a closed stream');\n    }\n  } else {\n    assert(state === 'readable');\n    if (view.byteLength === 0) {\n      throw new TypeError(\n        'The view\\'s length must be greater than 0 when calling respondWithNewView() on a readable stream'\n      );\n    }\n  }\n\n  if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n    throw new RangeError('The region specified by view does not match byobRequest');\n  }\n  if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {\n    throw new RangeError('The buffer of view has different capacity than byobRequest');\n  }\n  if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {\n    throw new RangeError('The region specified by view is larger than byobRequest');\n  }\n\n  const viewByteLength = view.byteLength;\n  firstDescriptor.buffer = TransferArrayBuffer(view.buffer);\n  ReadableByteStreamControllerRespondInternal(controller, viewByteLength);\n}\n\nexport function SetUpReadableByteStreamController(stream: ReadableByteStream,\n                                                  controller: ReadableByteStreamController,\n                                                  startAlgorithm: () => void | PromiseLike<void>,\n                                                  pullAlgorithm: () => Promise<void>,\n                                                  cancelAlgorithm: (reason: any) => Promise<void>,\n                                                  highWaterMark: number,\n                                                  autoAllocateChunkSize: number | undefined) {\n  assert(stream._readableStreamController === undefined);\n  if (autoAllocateChunkSize !== undefined) {\n    assert(NumberIsInteger(autoAllocateChunkSize));\n    assert(autoAllocateChunkSize > 0);\n  }\n\n  controller._controlledReadableByteStream = stream;\n\n  controller._pullAgain = false;\n  controller._pulling = false;\n\n  controller._byobRequest = null;\n\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n  controller._queue = controller._queueTotalSize = undefined!;\n  ResetQueue(controller);\n\n  controller._closeRequested = false;\n  controller._started = false;\n\n  controller._strategyHWM = highWaterMark;\n\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n\n  controller._autoAllocateChunkSize = autoAllocateChunkSize;\n\n  controller._pendingPullIntos = new SimpleQueue();\n\n  stream._readableStreamController = controller;\n\n  const startResult = startAlgorithm();\n  uponPromise(\n    promiseResolvedWith(startResult),\n    () => {\n      controller._started = true;\n\n      assert(!controller._pulling);\n      assert(!controller._pullAgain);\n\n      ReadableByteStreamControllerCallPullIfNeeded(controller);\n      return null;\n    },\n    r => {\n      ReadableByteStreamControllerError(controller, r);\n      return null;\n    }\n  );\n}\n\nexport function SetUpReadableByteStreamControllerFromUnderlyingSource(\n  stream: ReadableByteStream,\n  underlyingByteSource: ValidatedUnderlyingByteSource,\n  highWaterMark: number\n) {\n  const controller: ReadableByteStreamController = Object.create(ReadableByteStreamController.prototype);\n\n  let startAlgorithm: () => void | PromiseLike<void>;\n  let pullAlgorithm: () => Promise<void>;\n  let cancelAlgorithm: (reason: any) => Promise<void>;\n\n  if (underlyingByteSource.start !== undefined) {\n    startAlgorithm = () => underlyingByteSource.start!(controller);\n  } else {\n    startAlgorithm = () => undefined;\n  }\n  if (underlyingByteSource.pull !== undefined) {\n    pullAlgorithm = () => underlyingByteSource.pull!(controller);\n  } else {\n    pullAlgorithm = () => promiseResolvedWith(undefined);\n  }\n  if (underlyingByteSource.cancel !== undefined) {\n    cancelAlgorithm = reason => underlyingByteSource.cancel!(reason);\n  } else {\n    cancelAlgorithm = () => promiseResolvedWith(undefined);\n  }\n\n  const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n  if (autoAllocateChunkSize === 0) {\n    throw new TypeError('autoAllocateChunkSize must be greater than 0');\n  }\n\n  SetUpReadableByteStreamController(\n    stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize\n  );\n}\n\nfunction SetUpReadableStreamBYOBRequest(request: ReadableStreamBYOBRequest,\n                                        controller: ReadableByteStreamController,\n                                        view: NonShared<ArrayBufferView>) {\n  assert(IsReadableByteStreamController(controller));\n  assert(typeof view === 'object');\n  assert(ArrayBuffer.isView(view));\n  assert(!IsDetachedBuffer(view.buffer));\n  request._associatedReadableByteStreamController = controller;\n  request._view = view;\n}\n\n// Helper functions for the ReadableStreamBYOBRequest.\n\nfunction byobRequestBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n}\n\n// Helper functions for the ReadableByteStreamController.\n\nfunction byteStreamControllerBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n}\n", "import { assertDictionary, convertUnsignedLongLongWithEnforceRange } from './basic';\nimport type {\n  ReadableStreamBYOBReaderReadOptions,\n  ReadableStreamGetReaderOptions,\n  ValidatedReadableStreamBYOBReaderReadOptions\n} from '../readable-stream/reader-options';\n\nexport function convertReaderOptions(options: ReadableStreamGetReaderOptions | null | undefined,\n                                     context: string): ReadableStreamGetReaderOptions {\n  assertDictionary(options, context);\n  const mode = options?.mode;\n  return {\n    mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)\n  };\n}\n\nfunction convertReadableStreamReaderMode(mode: string, context: string): 'byob' {\n  mode = `${mode}`;\n  if (mode !== 'byob') {\n    throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);\n  }\n  return mode;\n}\n\nexport function convertByobReadOptions(\n  options: ReadableStreamBYOBReaderReadOptions | null | undefined,\n  context: string\n): ValidatedReadableStreamBYOBReaderReadOptions {\n  assertDictionary(options, context);\n  const min = options?.min ?? 1;\n  return {\n    min: convertUnsignedLongLongWithEnforceRange(\n      min,\n      `${context} has member 'min' that`\n    )\n  };\n}\n", "import assert from '../../stub/assert';\nimport { SimpleQueue } from '../simple-queue';\nimport {\n  ReadableStreamReaderGenericCancel,\n  ReadableStreamReaderGenericInitialize,\n  ReadableStreamReaderGenericRelease,\n  readerLockException\n} from './generic-reader';\nimport { IsReadableStreamLocked, type ReadableByteStream, type ReadableStream } from '../readable-stream';\nimport {\n  IsReadableByteStreamController,\n  ReadableByteStreamController,\n  ReadableByteStreamControllerPullInto\n} from './byte-stream-controller';\nimport { setFunctionName, typeIsObject } from '../helpers/miscellaneous';\nimport { newPromise, promiseRejectedWith } from '../helpers/webidl';\nimport { assertRequiredArgument } from '../validators/basic';\nimport { assertReadableStream } from '../validators/readable-stream';\nimport { IsDetachedBuffer } from '../abstract-ops/ecmascript';\nimport type {\n  ReadableStreamBYOBReaderReadOptions,\n  ValidatedReadableStreamBYOBReaderReadOptions\n} from './reader-options';\nimport { convertByobReadOptions } from '../validators/reader-options';\nimport { isDataView, type NonShared, type TypedArray } from '../helpers/array-buffer-view';\n\n/**\n * A result returned by {@link ReadableStreamBYOBReader.read}.\n *\n * @public\n */\nexport type ReadableStreamBYOBReadResult<T extends ArrayBufferView> = {\n  done: false;\n  value: T;\n} | {\n  done: true;\n  value: T | undefined;\n};\n\n// Abstract operations for the ReadableStream.\n\nexport function AcquireReadableStreamBYOBReader(stream: ReadableByteStream): ReadableStreamBYOBReader {\n  return new ReadableStreamBYOBReader(stream as ReadableStream<Uint8Array>);\n}\n\n// ReadableStream API exposed for controllers.\n\nexport function ReadableStreamAddReadIntoRequest<T extends NonShared<ArrayBufferView>>(\n  stream: ReadableByteStream,\n  readIntoRequest: ReadIntoRequest<T>\n): void {\n  assert(IsReadableStreamBYOBReader(stream._reader));\n  assert(stream._state === 'readable' || stream._state === 'closed');\n\n  (stream._reader! as ReadableStreamBYOBReader)._readIntoRequests.push(readIntoRequest);\n}\n\nexport function ReadableStreamFulfillReadIntoRequest(stream: ReadableByteStream,\n                                                     chunk: ArrayBufferView,\n                                                     done: boolean) {\n  const reader = stream._reader as ReadableStreamBYOBReader;\n\n  assert(reader._readIntoRequests.length > 0);\n\n  const readIntoRequest = reader._readIntoRequests.shift()!;\n  if (done) {\n    readIntoRequest._closeSteps(chunk);\n  } else {\n    readIntoRequest._chunkSteps(chunk);\n  }\n}\n\nexport function ReadableStreamGetNumReadIntoRequests(stream: ReadableByteStream): number {\n  return (stream._reader as ReadableStreamBYOBReader)._readIntoRequests.length;\n}\n\nexport function ReadableStreamHasBYOBReader(stream: ReadableByteStream): boolean {\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (!IsReadableStreamBYOBReader(reader)) {\n    return false;\n  }\n\n  return true;\n}\n\n// Readers\n\nexport interface ReadIntoRequest<T extends NonShared<ArrayBufferView>> {\n  _chunkSteps(chunk: T): void;\n\n  _closeSteps(chunk: T | undefined): void;\n\n  _errorSteps(e: any): void;\n}\n\n/**\n * A BYOB reader vended by a {@link ReadableStream}.\n *\n * @public\n */\nexport class ReadableStreamBYOBReader {\n  /** @internal */\n  _ownerReadableStream!: ReadableByteStream;\n  /** @internal */\n  _closedPromise!: Promise<undefined>;\n  /** @internal */\n  _closedPromise_resolve?: (value?: undefined) => void;\n  /** @internal */\n  _closedPromise_reject?: (reason: any) => void;\n  /** @internal */\n  _readIntoRequests: SimpleQueue<ReadIntoRequest<any>>;\n\n  constructor(stream: ReadableStream<Uint8Array>) {\n    assertRequiredArgument(stream, 1, 'ReadableStreamBYOBReader');\n    assertReadableStream(stream, 'First parameter');\n\n    if (IsReadableStreamLocked(stream)) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    if (!IsReadableByteStreamController(stream._readableStreamController)) {\n      throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +\n        'source');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n\n    this._readIntoRequests = new SimpleQueue();\n  }\n\n  /**\n   * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n   * the reader's lock is released before the stream finishes closing.\n   */\n  get closed(): Promise<undefined> {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return promiseRejectedWith(byobReaderBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  /**\n   * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n   */\n  cancel(reason: any = undefined): Promise<void> {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return promiseRejectedWith(byobReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n\n  /**\n   * Attempts to reads bytes into view, and returns a promise resolved with the result.\n   *\n   * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n   */\n  read<T extends ArrayBufferView>(\n    view: T,\n    options?: ReadableStreamBYOBReaderReadOptions\n  ): Promise<ReadableStreamBYOBReadResult<T>>;\n  read<T extends NonShared<ArrayBufferView>>(\n    view: T,\n    rawOptions: ReadableStreamBYOBReaderReadOptions | null | undefined = {}\n  ): Promise<ReadableStreamBYOBReadResult<T>> {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return promiseRejectedWith(byobReaderBrandCheckException('read'));\n    }\n\n    if (!ArrayBuffer.isView(view)) {\n      return promiseRejectedWith(new TypeError('view must be an array buffer view'));\n    }\n    if (view.byteLength === 0) {\n      return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));\n    }\n    if (view.buffer.byteLength === 0) {\n      return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));\n    }\n    if (IsDetachedBuffer(view.buffer)) {\n      return promiseRejectedWith(new TypeError('view\\'s buffer has been detached'));\n    }\n\n    let options: ValidatedReadableStreamBYOBReaderReadOptions;\n    try {\n      options = convertByobReadOptions(rawOptions, 'options');\n    } catch (e) {\n      return promiseRejectedWith(e);\n    }\n    const min = options.min;\n    if (min === 0) {\n      return promiseRejectedWith(new TypeError('options.min must be greater than 0'));\n    }\n    if (!isDataView(view)) {\n      if (min > (view as unknown as TypedArray).length) {\n        return promiseRejectedWith(new RangeError('options.min must be less than or equal to view\\'s length'));\n      }\n    } else if (min > view.byteLength) {\n      return promiseRejectedWith(new RangeError('options.min must be less than or equal to view\\'s byteLength'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('read from'));\n    }\n\n    let resolvePromise!: (result: ReadableStreamBYOBReadResult<T>) => void;\n    let rejectPromise!: (reason: any) => void;\n    const promise = newPromise<ReadableStreamBYOBReadResult<T>>((resolve, reject) => {\n      resolvePromise = resolve;\n      rejectPromise = reject;\n    });\n    const readIntoRequest: ReadIntoRequest<T> = {\n      _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n      _closeSteps: chunk => resolvePromise({ value: chunk, done: true }),\n      _errorSteps: e => rejectPromise(e)\n    };\n    ReadableStreamBYOBReaderRead(this, view, min, readIntoRequest);\n    return promise;\n  }\n\n  /**\n   * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n   * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n   * from now on; otherwise, the reader will appear closed.\n   *\n   * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n   * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n   * do so will throw a `TypeError` and leave the reader locked to the stream.\n   */\n  releaseLock(): void {\n    if (!IsReadableStreamBYOBReader(this)) {\n      throw byobReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    ReadableStreamBYOBReaderRelease(this);\n  }\n}\n\nObject.defineProperties(ReadableStreamBYOBReader.prototype, {\n  cancel: { enumerable: true },\n  read: { enumerable: true },\n  releaseLock: { enumerable: true },\n  closed: { enumerable: true }\n});\nsetFunctionName(ReadableStreamBYOBReader.prototype.cancel, 'cancel');\nsetFunctionName(ReadableStreamBYOBReader.prototype.read, 'read');\nsetFunctionName(ReadableStreamBYOBReader.prototype.releaseLock, 'releaseLock');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStreamBYOBReader.prototype, Symbol.toStringTag, {\n    value: 'ReadableStreamBYOBReader',\n    configurable: true\n  });\n}\n\n// Abstract operations for the readers.\n\nexport function IsReadableStreamBYOBReader(x: any): x is ReadableStreamBYOBReader {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\n    return false;\n  }\n\n  return x instanceof ReadableStreamBYOBReader;\n}\n\nexport function ReadableStreamBYOBReaderRead<T extends NonShared<ArrayBufferView>>(\n  reader: ReadableStreamBYOBReader,\n  view: T,\n  min: number,\n  readIntoRequest: ReadIntoRequest<T>\n): void {\n  const stream = reader._ownerReadableStream;\n\n  assert(stream !== undefined);\n\n  stream._disturbed = true;\n\n  if (stream._state === 'errored') {\n    readIntoRequest._errorSteps(stream._storedError);\n  } else {\n    ReadableByteStreamControllerPullInto(\n      stream._readableStreamController as ReadableByteStreamController,\n      view,\n      min,\n      readIntoRequest\n    );\n  }\n}\n\nexport function ReadableStreamBYOBReaderRelease(reader: ReadableStreamBYOBReader) {\n  ReadableStreamReaderGenericRelease(reader);\n  const e = new TypeError('Reader was released');\n  ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);\n}\n\nexport function ReadableStreamBYOBReaderErrorReadIntoRequests(reader: ReadableStreamBYOBReader, e: any) {\n  const readIntoRequests = reader._readIntoRequests;\n  reader._readIntoRequests = new SimpleQueue();\n  readIntoRequests.forEach(readIntoRequest => {\n    readIntoRequest._errorSteps(e);\n  });\n}\n\n// Helper functions for the ReadableStreamBYOBReader.\n\nfunction byobReaderBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n}\n", "import type { QueuingStrategy, QueuingStrategySizeCallback } from '../queuing-strategy';\nimport NumberIsNaN from '../../stub/number-isnan';\n\nexport function ExtractHighWaterMark(strategy: QueuingStrategy, defaultHWM: number): number {\n  const { highWaterMark } = strategy;\n\n  if (highWaterMark === undefined) {\n    return defaultHWM;\n  }\n\n  if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\n    throw new RangeError('Invalid highWaterMark');\n  }\n\n  return highWaterMark;\n}\n\nexport function ExtractSizeAlgorithm<T>(strategy: QueuingStrategy<T>): QueuingStrategySizeCallback<T> {\n  const { size } = strategy;\n\n  if (!size) {\n    return () => 1;\n  }\n\n  return size;\n}\n", "import type { QueuingStrategy, QueuingStrategySizeCallback } from '../queuing-strategy';\nimport { assertDictionary, assertFunction, convertUnrestrictedDouble } from './basic';\n\nexport function convertQueuingStrategy<T>(init: QueuingStrategy<T> | null | undefined,\n                                          context: string): QueuingStrategy<T> {\n  assertDictionary(init, context);\n  const highWaterMark = init?.highWaterMark;\n  const size = init?.size;\n  return {\n    highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),\n    size: size === undefined ? undefined : convertQueuingStrategySize(size, `${context} has member 'size' that`)\n  };\n}\n\nfunction convertQueuingStrategySize<T>(fn: QueuingStrategySizeCallback<T>,\n                                       context: string): QueuingStrategySizeCallback<T> {\n  assertFunction(fn, context);\n  return chunk => convertUnrestrictedDouble(fn(chunk));\n}\n", "import { assertDictionary, assertFunction } from './basic';\nimport { promiseCall, reflectCall } from '../helpers/webidl';\nimport type {\n  UnderlyingSink,\n  UnderlyingSinkAbortCallback,\n  UnderlyingSinkCloseCallback,\n  UnderlyingSinkStartCallback,\n  UnderlyingSinkWriteCallback,\n  ValidatedUnderlyingSink\n} from '../writable-stream/underlying-sink';\nimport { WritableStreamDefaultController } from '../writable-stream';\n\nexport function convertUnderlyingSink<W>(original: UnderlyingSink<W> | null,\n                                         context: string): ValidatedUnderlyingSink<W> {\n  assertDictionary(original, context);\n  const abort = original?.abort;\n  const close = original?.close;\n  const start = original?.start;\n  const type = original?.type;\n  const write = original?.write;\n  return {\n    abort: abort === undefined ?\n      undefined :\n      convertUnderlyingSinkAbortCallback(abort, original!, `${context} has member 'abort' that`),\n    close: close === undefined ?\n      undefined :\n      convertUnderlyingSinkCloseCallback(close, original!, `${context} has member 'close' that`),\n    start: start === undefined ?\n      undefined :\n      convertUnderlyingSinkStartCallback(start, original!, `${context} has member 'start' that`),\n    write: write === undefined ?\n      undefined :\n      convertUnderlyingSinkWriteCallback(write, original!, `${context} has member 'write' that`),\n    type\n  };\n}\n\nfunction convertUnderlyingSinkAbortCallback(\n  fn: UnderlyingSinkAbortCallback,\n  original: UnderlyingSink,\n  context: string\n): (reason: any) => Promise<void> {\n  assertFunction(fn, context);\n  return (reason: any) => promiseCall(fn, original, [reason]);\n}\n\nfunction convertUnderlyingSinkCloseCallback(\n  fn: UnderlyingSinkCloseCallback,\n  original: UnderlyingSink,\n  context: string\n): () => Promise<void> {\n  assertFunction(fn, context);\n  return () => promiseCall(fn, original, []);\n}\n\nfunction convertUnderlyingSinkStartCallback(\n  fn: UnderlyingSinkStartCallback,\n  original: UnderlyingSink,\n  context: string\n): UnderlyingSinkStartCallback {\n  assertFunction(fn, context);\n  return (controller: WritableStreamDefaultController) => reflectCall(fn, original, [controller]);\n}\n\nfunction convertUnderlyingSinkWriteCallback<W>(\n  fn: UnderlyingSinkWriteCallback<W>,\n  original: UnderlyingSink<W>,\n  context: string\n): (chunk: W, controller: WritableStreamDefaultController) => Promise<void> {\n  assertFunction(fn, context);\n  return (chunk: W, controller: WritableStreamDefaultController) => promiseCall(fn, original, [chunk, controller]);\n}\n", "import { IsWritableStream, WritableStream } from '../writable-stream';\n\nexport function assertWritableStream(x: unknown, context: string): asserts x is WritableStream {\n  if (!IsWritableStream(x)) {\n    throw new TypeError(`${context} is not a WritableStream.`);\n  }\n}\n", "/**\n * A signal object that allows you to communicate with a request and abort it if required\n * via its associated `AbortController` object.\n *\n * @remarks\n *   This interface is compatible with the `AbortSignal` interface defined in TypeScript's DOM types.\n *   It is redefined here, so it can be polyfilled without a DOM, for example with\n *   {@link https://www.npmjs.com/package/abortcontroller-polyfill | abortcontroller-polyfill} in a Node environment.\n *\n * @public\n */\nexport interface AbortSignal {\n  /**\n   * Whether the request is aborted.\n   */\n  readonly aborted: boolean;\n\n  /**\n   * If aborted, returns the reason for aborting.\n   */\n  readonly reason?: any;\n\n  /**\n   * Add an event listener to be triggered when this signal becomes aborted.\n   */\n  addEventListener(type: 'abort', listener: () => void): void;\n\n  /**\n   * Remove an event listener that was previously added with {@link AbortSignal.addEventListener}.\n   */\n  removeEventListener(type: 'abort', listener: () => void): void;\n}\n\nexport function isAbortSignal(value: unknown): value is AbortSignal {\n  if (typeof value !== 'object' || value === null) {\n    return false;\n  }\n  try {\n    return typeof (value as AbortSignal).aborted === 'boolean';\n  } catch {\n    // AbortSignal.prototype.aborted throws if its brand check fails\n    return false;\n  }\n}\n\n/**\n * A controller object that allows you to abort an `AbortSignal` when desired.\n *\n * @remarks\n *   This interface is compatible with the `AbortController` interface defined in TypeScript's DOM types.\n *   It is redefined here, so it can be polyfilled without a DOM, for example with\n *   {@link https://www.npmjs.com/package/abortcontroller-polyfill | abortcontroller-polyfill} in a Node environment.\n *\n * @internal\n */\nexport interface AbortController {\n  readonly signal: AbortSignal;\n\n  abort(reason?: any): void;\n}\n\ninterface AbortControllerConstructor {\n  new(): AbortController;\n}\n\nconst supportsAbortController = typeof (AbortController as any) === 'function';\n\n/**\n * Construct a new AbortController, if supported by the platform.\n *\n * @internal\n */\nexport function createAbortController(): AbortController | undefined {\n  if (supportsAbortController) {\n    return new (AbortController as AbortControllerConstructor)();\n  }\n  return undefined;\n}\n", "import assert from '../stub/assert';\nimport {\n  newPromise,\n  promiseRejectedWith,\n  promiseResolvedWith,\n  setPromiseIsHandledToTrue,\n  uponPromise\n} from './helpers/webidl';\nimport {\n  DequeueValue,\n  EnqueueValueWithSize,\n  PeekQueueValue,\n  type QueuePair,\n  ResetQueue\n} from './abstract-ops/queue-with-sizes';\nimport type { QueuingStrategy, QueuingStrategySizeCallback } from './queuing-strategy';\nimport { SimpleQueue } from './simple-queue';\nimport { setFunctionName, typeIsObject } from './helpers/miscellaneous';\nimport { AbortSteps, ErrorSteps } from './abstract-ops/internal-methods';\nimport { IsNonNegativeNumber } from './abstract-ops/miscellaneous';\nimport { ExtractHighWaterMark, ExtractSizeAlgorithm } from './abstract-ops/queuing-strategy';\nimport { convertQueuingStrategy } from './validators/queuing-strategy';\nimport type {\n  UnderlyingSink,\n  UnderlyingSinkAbortCallback,\n  UnderlyingSinkCloseCallback,\n  UnderlyingSinkStartCallback,\n  UnderlyingSinkWriteCallback,\n  ValidatedUnderlyingSink\n} from './writable-stream/underlying-sink';\nimport { assertObject, assertRequiredArgument } from './validators/basic';\nimport { convertUnderlyingSink } from './validators/underlying-sink';\nimport { assertWritableStream } from './validators/writable-stream';\nimport { type AbortController, type AbortSignal, createAbortController } from './abort-signal';\n\ntype WritableStreamState = 'writable' | 'closed' | 'erroring' | 'errored';\n\ninterface WriteOrCloseRequest {\n  _resolve: (value?: undefined) => void;\n  _reject: (reason: any) => void;\n}\n\ntype WriteRequest = WriteOrCloseRequest;\ntype CloseRequest = WriteOrCloseRequest;\n\ninterface PendingAbortRequest {\n  _promise: Promise<undefined>;\n  _resolve: (value?: undefined) => void;\n  _reject: (reason: any) => void;\n  _reason: any;\n  _wasAlreadyErroring: boolean;\n}\n\n/**\n * A writable stream represents a destination for data, into which you can write.\n *\n * @public\n */\nclass WritableStream<W = any> {\n  /** @internal */\n  _state!: WritableStreamState;\n  /** @internal */\n  _storedError: any;\n  /** @internal */\n  _writer: WritableStreamDefaultWriter<W> | undefined;\n  /** @internal */\n  _writableStreamController!: WritableStreamDefaultController<W>;\n  /** @internal */\n  _writeRequests!: SimpleQueue<WriteRequest>;\n  /** @internal */\n  _inFlightWriteRequest: WriteRequest | undefined;\n  /** @internal */\n  _closeRequest: CloseRequest | undefined;\n  /** @internal */\n  _inFlightCloseRequest: CloseRequest | undefined;\n  /** @internal */\n  _pendingAbortRequest: PendingAbortRequest | undefined;\n  /** @internal */\n  _backpressure!: boolean;\n\n  constructor(underlyingSink?: UnderlyingSink<W>, strategy?: QueuingStrategy<W>);\n  constructor(rawUnderlyingSink: UnderlyingSink<W> | null | undefined = {},\n              rawStrategy: QueuingStrategy<W> | null | undefined = {}) {\n    if (rawUnderlyingSink === undefined) {\n      rawUnderlyingSink = null;\n    } else {\n      assertObject(rawUnderlyingSink, 'First parameter');\n    }\n\n    const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n    const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, 'First parameter');\n\n    InitializeWritableStream(this);\n\n    const type = underlyingSink.type;\n    if (type !== undefined) {\n      throw new RangeError('Invalid type is specified');\n    }\n\n    const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n    const highWaterMark = ExtractHighWaterMark(strategy, 1);\n\n    SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n  }\n\n  /**\n   * Returns whether or not the writable stream is locked to a writer.\n   */\n  get locked(): boolean {\n    if (!IsWritableStream(this)) {\n      throw streamBrandCheckException('locked');\n    }\n\n    return IsWritableStreamLocked(this);\n  }\n\n  /**\n   * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n   * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n   * mechanism of the underlying sink.\n   *\n   * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled\n   * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel\n   * the stream) if the stream is currently locked.\n   */\n  abort(reason: any = undefined): Promise<void> {\n    if (!IsWritableStream(this)) {\n      return promiseRejectedWith(streamBrandCheckException('abort'));\n    }\n\n    if (IsWritableStreamLocked(this)) {\n      return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));\n    }\n\n    return WritableStreamAbort(this, reason);\n  }\n\n  /**\n   * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n   * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n   *\n   * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n   * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with\n   * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.\n   */\n  close() {\n    if (!IsWritableStream(this)) {\n      return promiseRejectedWith(streamBrandCheckException('close'));\n    }\n\n    if (IsWritableStreamLocked(this)) {\n      return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));\n    }\n\n    if (WritableStreamCloseQueuedOrInFlight(this)) {\n      return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n    }\n\n    return WritableStreamClose(this);\n  }\n\n  /**\n   * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n   * is locked, no other writer can be acquired until this one is released.\n   *\n   * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n   * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n   * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n   */\n  getWriter(): WritableStreamDefaultWriter<W> {\n    if (!IsWritableStream(this)) {\n      throw streamBrandCheckException('getWriter');\n    }\n\n    return AcquireWritableStreamDefaultWriter(this);\n  }\n}\n\nObject.defineProperties(WritableStream.prototype, {\n  abort: { enumerable: true },\n  close: { enumerable: true },\n  getWriter: { enumerable: true },\n  locked: { enumerable: true }\n});\nsetFunctionName(WritableStream.prototype.abort, 'abort');\nsetFunctionName(WritableStream.prototype.close, 'close');\nsetFunctionName(WritableStream.prototype.getWriter, 'getWriter');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(WritableStream.prototype, Symbol.toStringTag, {\n    value: 'WritableStream',\n    configurable: true\n  });\n}\n\nexport {\n  AcquireWritableStreamDefaultWriter,\n  CreateWritableStream,\n  IsWritableStream,\n  IsWritableStreamLocked,\n  WritableStream,\n  WritableStreamAbort,\n  WritableStreamDefaultControllerErrorIfNeeded,\n  WritableStreamDefaultWriterCloseWithErrorPropagation,\n  WritableStreamDefaultWriterRelease,\n  WritableStreamDefaultWriterWrite,\n  WritableStreamCloseQueuedOrInFlight\n};\n\nexport type {\n  UnderlyingSink,\n  UnderlyingSinkStartCallback,\n  UnderlyingSinkWriteCallback,\n  UnderlyingSinkCloseCallback,\n  UnderlyingSinkAbortCallback\n};\n\n// Abstract operations for the WritableStream.\n\nfunction AcquireWritableStreamDefaultWriter<W>(stream: WritableStream<W>): WritableStreamDefaultWriter<W> {\n  return new WritableStreamDefaultWriter(stream);\n}\n\n// Throws if and only if startAlgorithm throws.\nfunction CreateWritableStream<W>(startAlgorithm: () => void | PromiseLike<void>,\n                                 writeAlgorithm: (chunk: W) => Promise<void>,\n                                 closeAlgorithm: () => Promise<void>,\n                                 abortAlgorithm: (reason: any) => Promise<void>,\n                                 highWaterMark = 1,\n                                 sizeAlgorithm: QueuingStrategySizeCallback<W> = () => 1) {\n  assert(IsNonNegativeNumber(highWaterMark));\n\n  const stream: WritableStream<W> = Object.create(WritableStream.prototype);\n  InitializeWritableStream(stream);\n\n  const controller: WritableStreamDefaultController<W> = Object.create(WritableStreamDefaultController.prototype);\n\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\n                                       abortAlgorithm, highWaterMark, sizeAlgorithm);\n  return stream;\n}\n\nfunction InitializeWritableStream<W>(stream: WritableStream<W>) {\n  stream._state = 'writable';\n\n  // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n  // 'erroring' or 'errored'. May be set to an undefined value.\n  stream._storedError = undefined;\n\n  stream._writer = undefined;\n\n  // Initialize to undefined first because the constructor of the controller checks this\n  // variable to validate the caller.\n  stream._writableStreamController = undefined!;\n\n  // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n  // producer without waiting for the queued writes to finish.\n  stream._writeRequests = new SimpleQueue();\n\n  // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n  // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n  stream._inFlightWriteRequest = undefined;\n\n  // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n  // has been detached.\n  stream._closeRequest = undefined;\n\n  // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n  // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n  stream._inFlightCloseRequest = undefined;\n\n  // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n  stream._pendingAbortRequest = undefined;\n\n  // The backpressure signal set by the controller.\n  stream._backpressure = false;\n}\n\nfunction IsWritableStream(x: unknown): x is WritableStream {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\n    return false;\n  }\n\n  return x instanceof WritableStream;\n}\n\nfunction IsWritableStreamLocked(stream: WritableStream): boolean {\n  assert(IsWritableStream(stream));\n\n  if (stream._writer === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamAbort(stream: WritableStream, reason: any): Promise<undefined> {\n  if (stream._state === 'closed' || stream._state === 'errored') {\n    return promiseResolvedWith(undefined);\n  }\n  stream._writableStreamController._abortReason = reason;\n  stream._writableStreamController._abortController?.abort(reason);\n\n  // TypeScript narrows the type of `stream._state` down to 'writable' | 'erroring',\n  // but it doesn't know that signaling abort runs author code that might have changed the state.\n  // Widen the type again by casting to WritableStreamState.\n  const state = stream._state as WritableStreamState;\n\n  if (state === 'closed' || state === 'errored') {\n    return promiseResolvedWith(undefined);\n  }\n  if (stream._pendingAbortRequest !== undefined) {\n    return stream._pendingAbortRequest._promise;\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n\n  let wasAlreadyErroring = false;\n  if (state === 'erroring') {\n    wasAlreadyErroring = true;\n    // reason will not be used, so don't keep a reference to it.\n    reason = undefined;\n  }\n\n  const promise = newPromise<undefined>((resolve, reject) => {\n    stream._pendingAbortRequest = {\n      _promise: undefined!,\n      _resolve: resolve,\n      _reject: reject,\n      _reason: reason,\n      _wasAlreadyErroring: wasAlreadyErroring\n    };\n  });\n  stream._pendingAbortRequest!._promise = promise;\n\n  if (!wasAlreadyErroring) {\n    WritableStreamStartErroring(stream, reason);\n  }\n\n  return promise;\n}\n\nfunction WritableStreamClose(stream: WritableStream<any>): Promise<undefined> {\n  const state = stream._state;\n  if (state === 'closed' || state === 'errored') {\n    return promiseRejectedWith(new TypeError(\n      `The stream (in ${state} state) is not in the writable state and cannot be closed`));\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n  assert(!WritableStreamCloseQueuedOrInFlight(stream));\n\n  const promise = newPromise<undefined>((resolve, reject) => {\n    const closeRequest: CloseRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._closeRequest = closeRequest;\n  });\n\n  const writer = stream._writer;\n  if (writer !== undefined && stream._backpressure && state === 'writable') {\n    defaultWriterReadyPromiseResolve(writer);\n  }\n\n  WritableStreamDefaultControllerClose(stream._writableStreamController);\n\n  return promise;\n}\n\n// WritableStream API exposed for controllers.\n\nfunction WritableStreamAddWriteRequest(stream: WritableStream): Promise<undefined> {\n  assert(IsWritableStreamLocked(stream));\n  assert(stream._state === 'writable');\n\n  const promise = newPromise<undefined>((resolve, reject) => {\n    const writeRequest: WriteRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._writeRequests.push(writeRequest);\n  });\n\n  return promise;\n}\n\nfunction WritableStreamDealWithRejection(stream: WritableStream, error: any) {\n  const state = stream._state;\n\n  if (state === 'writable') {\n    WritableStreamStartErroring(stream, error);\n    return;\n  }\n\n  assert(state === 'erroring');\n  WritableStreamFinishErroring(stream);\n}\n\nfunction WritableStreamStartErroring(stream: WritableStream, reason: any) {\n  assert(stream._storedError === undefined);\n  assert(stream._state === 'writable');\n\n  const controller = stream._writableStreamController;\n  assert(controller !== undefined);\n\n  stream._state = 'erroring';\n  stream._storedError = reason;\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n  }\n\n  if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\n    WritableStreamFinishErroring(stream);\n  }\n}\n\nfunction WritableStreamFinishErroring(stream: WritableStream) {\n  assert(stream._state === 'erroring');\n  assert(!WritableStreamHasOperationMarkedInFlight(stream));\n  stream._state = 'errored';\n  stream._writableStreamController[ErrorSteps]();\n\n  const storedError = stream._storedError;\n  stream._writeRequests.forEach(writeRequest => {\n    writeRequest._reject(storedError);\n  });\n  stream._writeRequests = new SimpleQueue();\n\n  if (stream._pendingAbortRequest === undefined) {\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  const abortRequest = stream._pendingAbortRequest;\n  stream._pendingAbortRequest = undefined;\n\n  if (abortRequest._wasAlreadyErroring) {\n    abortRequest._reject(storedError);\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n  uponPromise(\n    promise,\n    () => {\n      abortRequest._resolve();\n      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n      return null;\n    },\n    (reason: any) => {\n      abortRequest._reject(reason);\n      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n      return null;\n    });\n}\n\nfunction WritableStreamFinishInFlightWrite(stream: WritableStream) {\n  assert(stream._inFlightWriteRequest !== undefined);\n  stream._inFlightWriteRequest!._resolve(undefined);\n  stream._inFlightWriteRequest = undefined;\n}\n\nfunction WritableStreamFinishInFlightWriteWithError(stream: WritableStream, error: any) {\n  assert(stream._inFlightWriteRequest !== undefined);\n  stream._inFlightWriteRequest!._reject(error);\n  stream._inFlightWriteRequest = undefined;\n\n  assert(stream._state === 'writable' || stream._state === 'erroring');\n\n  WritableStreamDealWithRejection(stream, error);\n}\n\nfunction WritableStreamFinishInFlightClose(stream: WritableStream) {\n  assert(stream._inFlightCloseRequest !== undefined);\n  stream._inFlightCloseRequest!._resolve(undefined);\n  stream._inFlightCloseRequest = undefined;\n\n  const state = stream._state;\n\n  assert(state === 'writable' || state === 'erroring');\n\n  if (state === 'erroring') {\n    // The error was too late to do anything, so it is ignored.\n    stream._storedError = undefined;\n    if (stream._pendingAbortRequest !== undefined) {\n      stream._pendingAbortRequest._resolve();\n      stream._pendingAbortRequest = undefined;\n    }\n  }\n\n  stream._state = 'closed';\n\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseResolve(writer);\n  }\n\n  assert(stream._pendingAbortRequest === undefined);\n  assert(stream._storedError === undefined);\n}\n\nfunction WritableStreamFinishInFlightCloseWithError(stream: WritableStream, error: any) {\n  assert(stream._inFlightCloseRequest !== undefined);\n  stream._inFlightCloseRequest!._reject(error);\n  stream._inFlightCloseRequest = undefined;\n\n  assert(stream._state === 'writable' || stream._state === 'erroring');\n\n  // Never execute sink abort() after sink close().\n  if (stream._pendingAbortRequest !== undefined) {\n    stream._pendingAbortRequest._reject(error);\n    stream._pendingAbortRequest = undefined;\n  }\n  WritableStreamDealWithRejection(stream, error);\n}\n\n// TODO(ricea): Fix alphabetical order.\nfunction WritableStreamCloseQueuedOrInFlight(stream: WritableStream): boolean {\n  if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamHasOperationMarkedInFlight(stream: WritableStream): boolean {\n  if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamMarkCloseRequestInFlight(stream: WritableStream) {\n  assert(stream._inFlightCloseRequest === undefined);\n  assert(stream._closeRequest !== undefined);\n  stream._inFlightCloseRequest = stream._closeRequest;\n  stream._closeRequest = undefined;\n}\n\nfunction WritableStreamMarkFirstWriteRequestInFlight(stream: WritableStream) {\n  assert(stream._inFlightWriteRequest === undefined);\n  assert(stream._writeRequests.length !== 0);\n  stream._inFlightWriteRequest = stream._writeRequests.shift();\n}\n\nfunction WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream: WritableStream) {\n  assert(stream._state === 'errored');\n  if (stream._closeRequest !== undefined) {\n    assert(stream._inFlightCloseRequest === undefined);\n\n    stream._closeRequest._reject(stream._storedError);\n    stream._closeRequest = undefined;\n  }\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseReject(writer, stream._storedError);\n  }\n}\n\nfunction WritableStreamUpdateBackpressure(stream: WritableStream, backpressure: boolean) {\n  assert(stream._state === 'writable');\n  assert(!WritableStreamCloseQueuedOrInFlight(stream));\n\n  const writer = stream._writer;\n  if (writer !== undefined && backpressure !== stream._backpressure) {\n    if (backpressure) {\n      defaultWriterReadyPromiseReset(writer);\n    } else {\n      assert(!backpressure);\n\n      defaultWriterReadyPromiseResolve(writer);\n    }\n  }\n\n  stream._backpressure = backpressure;\n}\n\n/**\n * A default writer vended by a {@link WritableStream}.\n *\n * @public\n */\nexport class WritableStreamDefaultWriter<W = any> {\n  /** @internal */\n  _ownerWritableStream: WritableStream<W>;\n  /** @internal */\n  _closedPromise!: Promise<undefined>;\n  /** @internal */\n  _closedPromise_resolve?: (value?: undefined) => void;\n  /** @internal */\n  _closedPromise_reject?: (reason: any) => void;\n  /** @internal */\n  _closedPromiseState!: 'pending' | 'resolved' | 'rejected';\n  /** @internal */\n  _readyPromise!: Promise<undefined>;\n  /** @internal */\n  _readyPromise_resolve?: (value?: undefined) => void;\n  /** @internal */\n  _readyPromise_reject?: (reason: any) => void;\n  /** @internal */\n  _readyPromiseState!: 'pending' | 'fulfilled' | 'rejected';\n\n  constructor(stream: WritableStream<W>) {\n    assertRequiredArgument(stream, 1, 'WritableStreamDefaultWriter');\n    assertWritableStream(stream, 'First parameter');\n\n    if (IsWritableStreamLocked(stream)) {\n      throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n    }\n\n    this._ownerWritableStream = stream;\n    stream._writer = this;\n\n    const state = stream._state;\n\n    if (state === 'writable') {\n      if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {\n        defaultWriterReadyPromiseInitialize(this);\n      } else {\n        defaultWriterReadyPromiseInitializeAsResolved(this);\n      }\n\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'erroring') {\n      defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'closed') {\n      defaultWriterReadyPromiseInitializeAsResolved(this);\n      defaultWriterClosedPromiseInitializeAsResolved(this);\n    } else {\n      assert(state === 'errored');\n\n      const storedError = stream._storedError;\n      defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n      defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n    }\n  }\n\n  /**\n   * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n   * the writers lock is released before the stream finishes closing.\n   */\n  get closed(): Promise<undefined> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  /**\n   * Returns the desired size to fill the streams internal queue. It can be negative, if the queue is over-full.\n   * A producer can use this information to determine the right amount of data to write.\n   *\n   * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n   * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n   * the writers lock is released.\n   */\n  get desiredSize(): number | null {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      throw defaultWriterBrandCheckException('desiredSize');\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      throw defaultWriterLockException('desiredSize');\n    }\n\n    return WritableStreamDefaultWriterGetDesiredSize(this);\n  }\n\n  /**\n   * Returns a promise that will be fulfilled when the desired size to fill the streams internal queue transitions\n   * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips\n   * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n   *\n   * If the stream becomes errored or aborted, or the writers lock is released, the returned promise will become\n   * rejected.\n   */\n  get ready(): Promise<undefined> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('ready'));\n    }\n\n    return this._readyPromise;\n  }\n\n  /**\n   * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n   */\n  abort(reason: any = undefined): Promise<void> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('abort'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return promiseRejectedWith(defaultWriterLockException('abort'));\n    }\n\n    return WritableStreamDefaultWriterAbort(this, reason);\n  }\n\n  /**\n   * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n   */\n  close(): Promise<void> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('close'));\n    }\n\n    const stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return promiseRejectedWith(defaultWriterLockException('close'));\n    }\n\n    if (WritableStreamCloseQueuedOrInFlight(stream)) {\n      return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n    }\n\n    return WritableStreamDefaultWriterClose(this);\n  }\n\n  /**\n   * Releases the writers lock on the corresponding stream. After the lock is released, the writer is no longer active.\n   * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n   * now on; otherwise, the writer will appear closed.\n   *\n   * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n   * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n   * Its not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n   * other producers from writing in an interleaved manner.\n   */\n  releaseLock(): void {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      throw defaultWriterBrandCheckException('releaseLock');\n    }\n\n    const stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return;\n    }\n\n    assert(stream._writer !== undefined);\n\n    WritableStreamDefaultWriterRelease(this);\n  }\n\n  /**\n   * Writes the given chunk to the writable stream, by waiting until any previous writes have finished successfully,\n   * and then sending the chunk to the underlying sink's {@link UnderlyingSink.write | write()} method. It will return\n   * a promise that fulfills with undefined upon a successful write, or rejects if the write fails or stream becomes\n   * errored before the writing process is initiated.\n   *\n   * Note that what \"success\" means is up to the underlying sink; it might indicate simply that the chunk has been\n   * accepted, and not necessarily that it is safely saved to its ultimate destination.\n   */\n  write(chunk: W): Promise<void>;\n  write(chunk: W = undefined!): Promise<void> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return promiseRejectedWith(defaultWriterLockException('write to'));\n    }\n\n    return WritableStreamDefaultWriterWrite(this, chunk);\n  }\n}\n\nObject.defineProperties(WritableStreamDefaultWriter.prototype, {\n  abort: { enumerable: true },\n  close: { enumerable: true },\n  releaseLock: { enumerable: true },\n  write: { enumerable: true },\n  closed: { enumerable: true },\n  desiredSize: { enumerable: true },\n  ready: { enumerable: true }\n});\nsetFunctionName(WritableStreamDefaultWriter.prototype.abort, 'abort');\nsetFunctionName(WritableStreamDefaultWriter.prototype.close, 'close');\nsetFunctionName(WritableStreamDefaultWriter.prototype.releaseLock, 'releaseLock');\nsetFunctionName(WritableStreamDefaultWriter.prototype.write, 'write');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, {\n    value: 'WritableStreamDefaultWriter',\n    configurable: true\n  });\n}\n\n// Abstract operations for the WritableStreamDefaultWriter.\n\nfunction IsWritableStreamDefaultWriter<W = any>(x: any): x is WritableStreamDefaultWriter<W> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\n    return false;\n  }\n\n  return x instanceof WritableStreamDefaultWriter;\n}\n\n// A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\n\nfunction WritableStreamDefaultWriterAbort(writer: WritableStreamDefaultWriter, reason: any) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  return WritableStreamAbort(stream, reason);\n}\n\nfunction WritableStreamDefaultWriterClose(writer: WritableStreamDefaultWriter): Promise<undefined> {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  return WritableStreamClose(stream);\n}\n\nfunction WritableStreamDefaultWriterCloseWithErrorPropagation(writer: WritableStreamDefaultWriter): Promise<undefined> {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const state = stream._state;\n  if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n    return promiseResolvedWith(undefined);\n  }\n\n  if (state === 'errored') {\n    return promiseRejectedWith(stream._storedError);\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n\n  return WritableStreamDefaultWriterClose(writer);\n}\n\nfunction WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer: WritableStreamDefaultWriter, error: any) {\n  if (writer._closedPromiseState === 'pending') {\n    defaultWriterClosedPromiseReject(writer, error);\n  } else {\n    defaultWriterClosedPromiseResetToRejected(writer, error);\n  }\n}\n\nfunction WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer: WritableStreamDefaultWriter, error: any) {\n  if (writer._readyPromiseState === 'pending') {\n    defaultWriterReadyPromiseReject(writer, error);\n  } else {\n    defaultWriterReadyPromiseResetToRejected(writer, error);\n  }\n}\n\nfunction WritableStreamDefaultWriterGetDesiredSize(writer: WritableStreamDefaultWriter): number | null {\n  const stream = writer._ownerWritableStream;\n  const state = stream._state;\n\n  if (state === 'errored' || state === 'erroring') {\n    return null;\n  }\n\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n}\n\nfunction WritableStreamDefaultWriterRelease(writer: WritableStreamDefaultWriter) {\n  const stream = writer._ownerWritableStream;\n  assert(stream !== undefined);\n  assert(stream._writer === writer);\n\n  const releasedError = new TypeError(\n    `Writer was released and can no longer be used to monitor the stream's closedness`);\n\n  WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n\n  // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n  // rejected until afterwards. This means that simply testing state will not work.\n  WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n\n  stream._writer = undefined;\n  writer._ownerWritableStream = undefined!;\n}\n\nfunction WritableStreamDefaultWriterWrite<W>(writer: WritableStreamDefaultWriter<W>, chunk: W): Promise<undefined> {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const controller = stream._writableStreamController;\n\n  const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n\n  if (stream !== writer._ownerWritableStream) {\n    return promiseRejectedWith(defaultWriterLockException('write to'));\n  }\n\n  const state = stream._state;\n  if (state === 'errored') {\n    return promiseRejectedWith(stream._storedError);\n  }\n  if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n    return promiseRejectedWith(new TypeError('The stream is closing or closed and cannot be written to'));\n  }\n  if (state === 'erroring') {\n    return promiseRejectedWith(stream._storedError);\n  }\n\n  assert(state === 'writable');\n\n  const promise = WritableStreamAddWriteRequest(stream);\n\n  WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n\n  return promise;\n}\n\nconst closeSentinel: unique symbol = {} as any;\n\ntype QueueRecord<W> = W | typeof closeSentinel;\n\n/**\n * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.\n *\n * @public\n */\nexport class WritableStreamDefaultController<W = any> {\n  /** @internal */\n  _controlledWritableStream!: WritableStream<W>;\n  /** @internal */\n  _queue!: SimpleQueue<QueuePair<QueueRecord<W>>>;\n  /** @internal */\n  _queueTotalSize!: number;\n  /** @internal */\n  _abortReason: any;\n  /** @internal */\n  _abortController: AbortController | undefined;\n  /** @internal */\n  _started!: boolean;\n  /** @internal */\n  _strategySizeAlgorithm!: QueuingStrategySizeCallback<W>;\n  /** @internal */\n  _strategyHWM!: number;\n  /** @internal */\n  _writeAlgorithm!: (chunk: W) => Promise<void>;\n  /** @internal */\n  _closeAlgorithm!: () => Promise<void>;\n  /** @internal */\n  _abortAlgorithm!: (reason: any) => Promise<void>;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.\n   *\n   * @deprecated\n   *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.\n   *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.\n   */\n  get abortReason(): any {\n    if (!IsWritableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('abortReason');\n    }\n    return this._abortReason;\n  }\n\n  /**\n   * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.\n   */\n  get signal(): AbortSignal {\n    if (!IsWritableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('signal');\n    }\n    if (this._abortController === undefined) {\n      // Older browsers or older Node versions may not support `AbortController` or `AbortSignal`.\n      // We don't want to bundle and ship an `AbortController` polyfill together with our polyfill,\n      // so instead we only implement support for `signal` if we find a global `AbortController` constructor.\n      throw new TypeError('WritableStreamDefaultController.prototype.signal is not supported');\n    }\n    return this._abortController.signal;\n  }\n\n  /**\n   * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.\n   *\n   * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying\n   * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the\n   * normal lifecycle of interactions with the underlying sink.\n   */\n  error(e: any = undefined): void {\n    if (!IsWritableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('error');\n    }\n    const state = this._controlledWritableStream._state;\n    if (state !== 'writable') {\n      // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n      // just treat it as a no-op.\n      return;\n    }\n\n    WritableStreamDefaultControllerError(this, e);\n  }\n\n  /** @internal */\n  [AbortSteps](reason: any): Promise<void> {\n    const result = this._abortAlgorithm(reason);\n    WritableStreamDefaultControllerClearAlgorithms(this);\n    return result;\n  }\n\n  /** @internal */\n  [ErrorSteps]() {\n    ResetQueue(this);\n  }\n}\n\nObject.defineProperties(WritableStreamDefaultController.prototype, {\n  abortReason: { enumerable: true },\n  signal: { enumerable: true },\n  error: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(WritableStreamDefaultController.prototype, Symbol.toStringTag, {\n    value: 'WritableStreamDefaultController',\n    configurable: true\n  });\n}\n\n// Abstract operations implementing interface required by the WritableStream.\n\nfunction IsWritableStreamDefaultController(x: any): x is WritableStreamDefaultController<any> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\n    return false;\n  }\n\n  return x instanceof WritableStreamDefaultController;\n}\n\nfunction SetUpWritableStreamDefaultController<W>(stream: WritableStream<W>,\n                                                 controller: WritableStreamDefaultController<W>,\n                                                 startAlgorithm: () => void | PromiseLike<void>,\n                                                 writeAlgorithm: (chunk: W) => Promise<void>,\n                                                 closeAlgorithm: () => Promise<void>,\n                                                 abortAlgorithm: (reason: any) => Promise<void>,\n                                                 highWaterMark: number,\n                                                 sizeAlgorithm: QueuingStrategySizeCallback<W>) {\n  assert(IsWritableStream(stream));\n  assert(stream._writableStreamController === undefined);\n\n  controller._controlledWritableStream = stream;\n  stream._writableStreamController = controller;\n\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n  controller._queue = undefined!;\n  controller._queueTotalSize = undefined!;\n  ResetQueue(controller);\n\n  controller._abortReason = undefined;\n  controller._abortController = createAbortController();\n  controller._started = false;\n\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n\n  controller._writeAlgorithm = writeAlgorithm;\n  controller._closeAlgorithm = closeAlgorithm;\n  controller._abortAlgorithm = abortAlgorithm;\n\n  const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n  WritableStreamUpdateBackpressure(stream, backpressure);\n\n  const startResult = startAlgorithm();\n  const startPromise = promiseResolvedWith(startResult);\n  uponPromise(\n    startPromise,\n    () => {\n      assert(stream._state === 'writable' || stream._state === 'erroring');\n      controller._started = true;\n      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n      return null;\n    },\n    r => {\n      assert(stream._state === 'writable' || stream._state === 'erroring');\n      controller._started = true;\n      WritableStreamDealWithRejection(stream, r);\n      return null;\n    }\n  );\n}\n\nfunction SetUpWritableStreamDefaultControllerFromUnderlyingSink<W>(stream: WritableStream<W>,\n                                                                   underlyingSink: ValidatedUnderlyingSink<W>,\n                                                                   highWaterMark: number,\n                                                                   sizeAlgorithm: QueuingStrategySizeCallback<W>) {\n  const controller = Object.create(WritableStreamDefaultController.prototype);\n\n  let startAlgorithm: () => void | PromiseLike<void>;\n  let writeAlgorithm: (chunk: W) => Promise<void>;\n  let closeAlgorithm: () => Promise<void>;\n  let abortAlgorithm: (reason: any) => Promise<void>;\n\n  if (underlyingSink.start !== undefined) {\n    startAlgorithm = () => underlyingSink.start!(controller);\n  } else {\n    startAlgorithm = () => undefined;\n  }\n  if (underlyingSink.write !== undefined) {\n    writeAlgorithm = chunk => underlyingSink.write!(chunk, controller);\n  } else {\n    writeAlgorithm = () => promiseResolvedWith(undefined);\n  }\n  if (underlyingSink.close !== undefined) {\n    closeAlgorithm = () => underlyingSink.close!();\n  } else {\n    closeAlgorithm = () => promiseResolvedWith(undefined);\n  }\n  if (underlyingSink.abort !== undefined) {\n    abortAlgorithm = reason => underlyingSink.abort!(reason);\n  } else {\n    abortAlgorithm = () => promiseResolvedWith(undefined);\n  }\n\n  SetUpWritableStreamDefaultController(\n    stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm\n  );\n}\n\n// ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\nfunction WritableStreamDefaultControllerClearAlgorithms(controller: WritableStreamDefaultController<any>) {\n  controller._writeAlgorithm = undefined!;\n  controller._closeAlgorithm = undefined!;\n  controller._abortAlgorithm = undefined!;\n  controller._strategySizeAlgorithm = undefined!;\n}\n\nfunction WritableStreamDefaultControllerClose<W>(controller: WritableStreamDefaultController<W>) {\n  EnqueueValueWithSize(controller, closeSentinel, 0);\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\nfunction WritableStreamDefaultControllerGetChunkSize<W>(controller: WritableStreamDefaultController<W>,\n                                                        chunk: W): number {\n  try {\n    return controller._strategySizeAlgorithm(chunk);\n  } catch (chunkSizeE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n    return 1;\n  }\n}\n\nfunction WritableStreamDefaultControllerGetDesiredSize(controller: WritableStreamDefaultController<any>): number {\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\nfunction WritableStreamDefaultControllerWrite<W>(controller: WritableStreamDefaultController<W>,\n                                                 chunk: W,\n                                                 chunkSize: number) {\n  try {\n    EnqueueValueWithSize(controller, chunk, chunkSize);\n  } catch (enqueueE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n    return;\n  }\n\n  const stream = controller._controlledWritableStream;\n  if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === 'writable') {\n    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n    WritableStreamUpdateBackpressure(stream, backpressure);\n  }\n\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\n// Abstract operations for the WritableStreamDefaultController.\n\nfunction WritableStreamDefaultControllerAdvanceQueueIfNeeded<W>(controller: WritableStreamDefaultController<W>) {\n  const stream = controller._controlledWritableStream;\n\n  if (!controller._started) {\n    return;\n  }\n\n  if (stream._inFlightWriteRequest !== undefined) {\n    return;\n  }\n\n  const state = stream._state;\n  assert(state !== 'closed' && state !== 'errored');\n  if (state === 'erroring') {\n    WritableStreamFinishErroring(stream);\n    return;\n  }\n\n  if (controller._queue.length === 0) {\n    return;\n  }\n\n  const value = PeekQueueValue(controller);\n  if (value === closeSentinel) {\n    WritableStreamDefaultControllerProcessClose(controller);\n  } else {\n    WritableStreamDefaultControllerProcessWrite(controller, value);\n  }\n}\n\nfunction WritableStreamDefaultControllerErrorIfNeeded(controller: WritableStreamDefaultController<any>, error: any) {\n  if (controller._controlledWritableStream._state === 'writable') {\n    WritableStreamDefaultControllerError(controller, error);\n  }\n}\n\nfunction WritableStreamDefaultControllerProcessClose(controller: WritableStreamDefaultController<any>) {\n  const stream = controller._controlledWritableStream;\n\n  WritableStreamMarkCloseRequestInFlight(stream);\n\n  DequeueValue(controller);\n  assert(controller._queue.length === 0);\n\n  const sinkClosePromise = controller._closeAlgorithm();\n  WritableStreamDefaultControllerClearAlgorithms(controller);\n  uponPromise(\n    sinkClosePromise,\n    () => {\n      WritableStreamFinishInFlightClose(stream);\n      return null;\n    },\n    reason => {\n      WritableStreamFinishInFlightCloseWithError(stream, reason);\n      return null;\n    }\n  );\n}\n\nfunction WritableStreamDefaultControllerProcessWrite<W>(controller: WritableStreamDefaultController<W>, chunk: W) {\n  const stream = controller._controlledWritableStream;\n\n  WritableStreamMarkFirstWriteRequestInFlight(stream);\n\n  const sinkWritePromise = controller._writeAlgorithm(chunk);\n  uponPromise(\n    sinkWritePromise,\n    () => {\n      WritableStreamFinishInFlightWrite(stream);\n\n      const state = stream._state;\n      assert(state === 'writable' || state === 'erroring');\n\n      DequeueValue(controller);\n\n      if (!WritableStreamCloseQueuedOrInFlight(stream) && state === 'writable') {\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n        WritableStreamUpdateBackpressure(stream, backpressure);\n      }\n\n      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n      return null;\n    },\n    reason => {\n      if (stream._state === 'writable') {\n        WritableStreamDefaultControllerClearAlgorithms(controller);\n      }\n      WritableStreamFinishInFlightWriteWithError(stream, reason);\n      return null;\n    }\n  );\n}\n\nfunction WritableStreamDefaultControllerGetBackpressure(controller: WritableStreamDefaultController<any>): boolean {\n  const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n  return desiredSize <= 0;\n}\n\n// A client of WritableStreamDefaultController may use these functions directly to bypass state check.\n\nfunction WritableStreamDefaultControllerError(controller: WritableStreamDefaultController<any>, error: any) {\n  const stream = controller._controlledWritableStream;\n\n  assert(stream._state === 'writable');\n\n  WritableStreamDefaultControllerClearAlgorithms(controller);\n  WritableStreamStartErroring(stream, error);\n}\n\n// Helper functions for the WritableStream.\n\nfunction streamBrandCheckException(name: string): TypeError {\n  return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n}\n\n// Helper functions for the WritableStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);\n}\n\n\n// Helper functions for the WritableStreamDefaultWriter.\n\nfunction defaultWriterBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n}\n\nfunction defaultWriterLockException(name: string): TypeError {\n  return new TypeError('Cannot ' + name + ' a stream using a released writer');\n}\n\nfunction defaultWriterClosedPromiseInitialize(writer: WritableStreamDefaultWriter) {\n  writer._closedPromise = newPromise((resolve, reject) => {\n    writer._closedPromise_resolve = resolve;\n    writer._closedPromise_reject = reject;\n    writer._closedPromiseState = 'pending';\n  });\n}\n\nfunction defaultWriterClosedPromiseInitializeAsRejected(writer: WritableStreamDefaultWriter, reason: any) {\n  defaultWriterClosedPromiseInitialize(writer);\n  defaultWriterClosedPromiseReject(writer, reason);\n}\n\nfunction defaultWriterClosedPromiseInitializeAsResolved(writer: WritableStreamDefaultWriter) {\n  defaultWriterClosedPromiseInitialize(writer);\n  defaultWriterClosedPromiseResolve(writer);\n}\n\nfunction defaultWriterClosedPromiseReject(writer: WritableStreamDefaultWriter, reason: any) {\n  if (writer._closedPromise_reject === undefined) {\n    return;\n  }\n  assert(writer._closedPromiseState === 'pending');\n\n  setPromiseIsHandledToTrue(writer._closedPromise);\n  writer._closedPromise_reject(reason);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseResetToRejected(writer: WritableStreamDefaultWriter, reason: any) {\n  assert(writer._closedPromise_resolve === undefined);\n  assert(writer._closedPromise_reject === undefined);\n  assert(writer._closedPromiseState !== 'pending');\n\n  defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n}\n\nfunction defaultWriterClosedPromiseResolve(writer: WritableStreamDefaultWriter) {\n  if (writer._closedPromise_resolve === undefined) {\n    return;\n  }\n  assert(writer._closedPromiseState === 'pending');\n\n  writer._closedPromise_resolve(undefined);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'resolved';\n}\n\nfunction defaultWriterReadyPromiseInitialize(writer: WritableStreamDefaultWriter) {\n  writer._readyPromise = newPromise((resolve, reject) => {\n    writer._readyPromise_resolve = resolve;\n    writer._readyPromise_reject = reject;\n  });\n  writer._readyPromiseState = 'pending';\n}\n\nfunction defaultWriterReadyPromiseInitializeAsRejected(writer: WritableStreamDefaultWriter, reason: any) {\n  defaultWriterReadyPromiseInitialize(writer);\n  defaultWriterReadyPromiseReject(writer, reason);\n}\n\nfunction defaultWriterReadyPromiseInitializeAsResolved(writer: WritableStreamDefaultWriter) {\n  defaultWriterReadyPromiseInitialize(writer);\n  defaultWriterReadyPromiseResolve(writer);\n}\n\nfunction defaultWriterReadyPromiseReject(writer: WritableStreamDefaultWriter, reason: any) {\n  if (writer._readyPromise_reject === undefined) {\n    return;\n  }\n\n  setPromiseIsHandledToTrue(writer._readyPromise);\n  writer._readyPromise_reject(reason);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseReset(writer: WritableStreamDefaultWriter) {\n  assert(writer._readyPromise_resolve === undefined);\n  assert(writer._readyPromise_reject === undefined);\n\n  defaultWriterReadyPromiseInitialize(writer);\n}\n\nfunction defaultWriterReadyPromiseResetToRejected(writer: WritableStreamDefaultWriter, reason: any) {\n  assert(writer._readyPromise_resolve === undefined);\n  assert(writer._readyPromise_reject === undefined);\n\n  defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n}\n\nfunction defaultWriterReadyPromiseResolve(writer: WritableStreamDefaultWriter) {\n  if (writer._readyPromise_resolve === undefined) {\n    return;\n  }\n\n  writer._readyPromise_resolve(undefined);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'fulfilled';\n}\n", "/// <reference lib=\"dom\" />\n\nfunction getGlobals(): typeof globalThis | undefined {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  }\n  return undefined;\n}\n\nexport const globals = getGlobals();\n", "/// <reference types=\"node\" />\nimport { globals } from '../globals';\nimport { setFunctionName } from '../lib/helpers/miscellaneous';\n\ninterface DOMException extends Error {\n  name: string;\n  message: string;\n}\n\ntype DOMExceptionConstructor = new (message?: string, name?: string) => DOMException;\n\nfunction isDOMExceptionConstructor(ctor: unknown): ctor is DOMExceptionConstructor {\n  if (!(typeof ctor === 'function' || typeof ctor === 'object')) {\n    return false;\n  }\n  if ((ctor as DOMExceptionConstructor).name !== 'DOMException') {\n    return false;\n  }\n  try {\n    new (ctor as DOMExceptionConstructor)();\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Support:\n * - Web browsers\n * - Node 18 and higher (https://github.com/nodejs/node/commit/e4b1fb5e6422c1ff151234bb9de792d45dd88d87)\n */\nfunction getFromGlobal(): DOMExceptionConstructor | undefined {\n  const ctor = globals?.DOMException;\n  return isDOMExceptionConstructor(ctor) ? ctor : undefined;\n}\n\n/**\n * Support:\n * - All platforms\n */\nfunction createPolyfill(): DOMExceptionConstructor {\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  const ctor = function DOMException(this: DOMException, message?: string, name?: string) {\n    this.message = message || '';\n    this.name = name || 'Error';\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  } as any;\n  setFunctionName(ctor, 'DOMException');\n  ctor.prototype = Object.create(Error.prototype);\n  Object.defineProperty(ctor.prototype, 'constructor', { value: ctor, writable: true, configurable: true });\n  return ctor;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nconst DOMException: DOMExceptionConstructor = getFromGlobal() || createPolyfill();\n\nexport { DOMException };\n", "import { IsReadableStream, IsReadableStreamLocked, ReadableStream, ReadableStreamCancel } from '../readable-stream';\nimport { AcquireReadableStreamDefaultReader, ReadableStreamDefaultReaderRead } from './default-reader';\nimport { ReadableStreamReaderGenericRelease } from './generic-reader';\nimport {\n  AcquireWritableStreamDefaultWriter,\n  IsWritableStream,\n  IsWritableStreamLocked,\n  WritableStream,\n  WritableStreamAbort,\n  WritableStreamCloseQueuedOrInFlight,\n  WritableStreamDefaultWriterCloseWithErrorPropagation,\n  WritableStreamDefaultWriterRelease,\n  WritableStreamDefaultWriterWrite\n} from '../writable-stream';\nimport assert from '../../stub/assert';\nimport {\n  newPromise,\n  PerformPromiseThen,\n  promiseResolvedWith,\n  setPromiseIsHandledToTrue,\n  uponFulfillment,\n  uponPromise,\n  uponRejection\n} from '../helpers/webidl';\nimport { noop } from '../../utils';\nimport { type AbortSignal, isAbortSignal } from '../abort-signal';\nimport { DOMException } from '../../stub/dom-exception';\n\nexport function ReadableStreamPipeTo<T>(source: ReadableStream<T>,\n                                        dest: WritableStream<T>,\n                                        preventClose: boolean,\n                                        preventAbort: boolean,\n                                        preventCancel: boolean,\n                                        signal: AbortSignal | undefined): Promise<undefined> {\n  assert(IsReadableStream(source));\n  assert(IsWritableStream(dest));\n  assert(typeof preventClose === 'boolean');\n  assert(typeof preventAbort === 'boolean');\n  assert(typeof preventCancel === 'boolean');\n  assert(signal === undefined || isAbortSignal(signal));\n  assert(!IsReadableStreamLocked(source));\n  assert(!IsWritableStreamLocked(dest));\n\n  const reader = AcquireReadableStreamDefaultReader<T>(source);\n  const writer = AcquireWritableStreamDefaultWriter<T>(dest);\n\n  source._disturbed = true;\n\n  let shuttingDown = false;\n\n  // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n  let currentWrite = promiseResolvedWith<void>(undefined);\n\n  return newPromise((resolve, reject) => {\n    let abortAlgorithm: () => void;\n    if (signal !== undefined) {\n      abortAlgorithm = () => {\n        const error = signal.reason !== undefined ? signal.reason : new DOMException('Aborted', 'AbortError');\n        const actions: Array<() => Promise<void>> = [];\n        if (!preventAbort) {\n          actions.push(() => {\n            if (dest._state === 'writable') {\n              return WritableStreamAbort(dest, error);\n            }\n            return promiseResolvedWith(undefined);\n          });\n        }\n        if (!preventCancel) {\n          actions.push(() => {\n            if (source._state === 'readable') {\n              return ReadableStreamCancel(source, error);\n            }\n            return promiseResolvedWith(undefined);\n          });\n        }\n        shutdownWithAction(() => Promise.all(actions.map(action => action())), true, error);\n      };\n\n      if (signal.aborted) {\n        abortAlgorithm();\n        return;\n      }\n\n      signal.addEventListener('abort', abortAlgorithm);\n    }\n\n    // Using reader and writer, read all chunks from this and write them to dest\n    // - Backpressure must be enforced\n    // - Shutdown must stop all activity\n    function pipeLoop() {\n      return newPromise<void>((resolveLoop, rejectLoop) => {\n        function next(done: boolean) {\n          if (done) {\n            resolveLoop();\n          } else {\n            // Use `PerformPromiseThen` instead of `uponPromise` to avoid\n            // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers\n            PerformPromiseThen(pipeStep(), next, rejectLoop);\n          }\n        }\n\n        next(false);\n      });\n    }\n\n    function pipeStep(): Promise<boolean> {\n      if (shuttingDown) {\n        return promiseResolvedWith(true);\n      }\n\n      return PerformPromiseThen(writer._readyPromise, () => {\n        return newPromise<boolean>((resolveRead, rejectRead) => {\n          ReadableStreamDefaultReaderRead(\n            reader,\n            {\n              _chunkSteps: chunk => {\n                currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);\n                resolveRead(false);\n              },\n              _closeSteps: () => resolveRead(true),\n              _errorSteps: rejectRead\n            }\n          );\n        });\n      });\n    }\n\n    // Errors must be propagated forward\n    isOrBecomesErrored(source, reader._closedPromise, storedError => {\n      if (!preventAbort) {\n        shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n      } else {\n        shutdown(true, storedError);\n      }\n      return null;\n    });\n\n    // Errors must be propagated backward\n    isOrBecomesErrored(dest, writer._closedPromise, storedError => {\n      if (!preventCancel) {\n        shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);\n      } else {\n        shutdown(true, storedError);\n      }\n      return null;\n    });\n\n    // Closing must be propagated forward\n    isOrBecomesClosed(source, reader._closedPromise, () => {\n      if (!preventClose) {\n        shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n      } else {\n        shutdown();\n      }\n      return null;\n    });\n\n    // Closing must be propagated backward\n    if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === 'closed') {\n      const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\n\n      if (!preventCancel) {\n        shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);\n      } else {\n        shutdown(true, destClosed);\n      }\n    }\n\n    setPromiseIsHandledToTrue(pipeLoop());\n\n    function waitForWritesToFinish(): Promise<void> {\n      // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n      // for that too.\n      const oldCurrentWrite = currentWrite;\n      return PerformPromiseThen(\n        currentWrite,\n        () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined\n      );\n    }\n\n    function isOrBecomesErrored(stream: ReadableStream | WritableStream,\n                                promise: Promise<void>,\n                                action: (reason: any) => null) {\n      if (stream._state === 'errored') {\n        action(stream._storedError);\n      } else {\n        uponRejection(promise, action);\n      }\n    }\n\n    function isOrBecomesClosed(stream: ReadableStream | WritableStream, promise: Promise<void>, action: () => null) {\n      if (stream._state === 'closed') {\n        action();\n      } else {\n        uponFulfillment(promise, action);\n      }\n    }\n\n    function shutdownWithAction(action: () => Promise<unknown>, originalIsError?: boolean, originalError?: any) {\n      if (shuttingDown) {\n        return;\n      }\n      shuttingDown = true;\n\n      if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n        uponFulfillment(waitForWritesToFinish(), doTheRest);\n      } else {\n        doTheRest();\n      }\n\n      function doTheRest(): null {\n        uponPromise(\n          action(),\n          () => finalize(originalIsError, originalError),\n          newError => finalize(true, newError)\n        );\n        return null;\n      }\n    }\n\n    function shutdown(isError?: boolean, error?: any) {\n      if (shuttingDown) {\n        return;\n      }\n      shuttingDown = true;\n\n      if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n        uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));\n      } else {\n        finalize(isError, error);\n      }\n    }\n\n    function finalize(isError?: boolean, error?: any): null {\n      WritableStreamDefaultWriterRelease(writer);\n      ReadableStreamReaderGenericRelease(reader);\n\n      if (signal !== undefined) {\n        signal.removeEventListener('abort', abortAlgorithm);\n      }\n      if (isError) {\n        reject(error);\n      } else {\n        resolve(undefined);\n      }\n\n      return null;\n    }\n  });\n}\n", "import type { QueuingStrategySizeCallback } from '../queuing-strategy';\nimport assert from '../../stub/assert';\nimport { DequeueValue, EnqueueValueWithSize, type QueuePair, ResetQueue } from '../abstract-ops/queue-with-sizes';\nimport {\n  ReadableStreamAddReadRequest,\n  ReadableStreamFulfillReadRequest,\n  ReadableStreamGetNumReadRequests,\n  type ReadRequest\n} from './default-reader';\nimport { SimpleQueue } from '../simple-queue';\nimport { IsReadableStreamLocked, ReadableStream, ReadableStreamClose, ReadableStreamError } from '../readable-stream';\nimport type { ValidatedUnderlyingSource } from './underlying-source';\nimport { setFunctionName, typeIsObject } from '../helpers/miscellaneous';\nimport { CancelSteps, PullSteps, ReleaseSteps } from '../abstract-ops/internal-methods';\nimport { promiseResolvedWith, uponPromise } from '../helpers/webidl';\n\n/**\n * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.\n *\n * @public\n */\nexport class ReadableStreamDefaultController<R> {\n  /** @internal */\n  _controlledReadableStream!: ReadableStream<R>;\n  /** @internal */\n  _queue!: SimpleQueue<QueuePair<R>>;\n  /** @internal */\n  _queueTotalSize!: number;\n  /** @internal */\n  _started!: boolean;\n  /** @internal */\n  _closeRequested!: boolean;\n  /** @internal */\n  _pullAgain!: boolean;\n  /** @internal */\n  _pulling !: boolean;\n  /** @internal */\n  _strategySizeAlgorithm!: QueuingStrategySizeCallback<R>;\n  /** @internal */\n  _strategyHWM!: number;\n  /** @internal */\n  _pullAlgorithm!: () => Promise<void>;\n  /** @internal */\n  _cancelAlgorithm!: (reason: any) => Promise<void>;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n   * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.\n   */\n  get desiredSize(): number | null {\n    if (!IsReadableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('desiredSize');\n    }\n\n    return ReadableStreamDefaultControllerGetDesiredSize(this);\n  }\n\n  /**\n   * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n   * the stream, but once those are read, the stream will become closed.\n   */\n  close(): void {\n    if (!IsReadableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('close');\n    }\n\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n      throw new TypeError('The stream is not in a state that permits close');\n    }\n\n    ReadableStreamDefaultControllerClose(this);\n  }\n\n  /**\n   * Enqueues the given chunk `chunk` in the controlled readable stream.\n   */\n  enqueue(chunk: R): void;\n  enqueue(chunk: R = undefined!): void {\n    if (!IsReadableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('enqueue');\n    }\n\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n      throw new TypeError('The stream is not in a state that permits enqueue');\n    }\n\n    return ReadableStreamDefaultControllerEnqueue(this, chunk);\n  }\n\n  /**\n   * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n   */\n  error(e: any = undefined): void {\n    if (!IsReadableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('error');\n    }\n\n    ReadableStreamDefaultControllerError(this, e);\n  }\n\n  /** @internal */\n  [CancelSteps](reason: any): Promise<void> {\n    ResetQueue(this);\n    const result = this._cancelAlgorithm(reason);\n    ReadableStreamDefaultControllerClearAlgorithms(this);\n    return result;\n  }\n\n  /** @internal */\n  [PullSteps](readRequest: ReadRequest<R>): void {\n    const stream = this._controlledReadableStream;\n\n    if (this._queue.length > 0) {\n      const chunk = DequeueValue(this);\n\n      if (this._closeRequested && this._queue.length === 0) {\n        ReadableStreamDefaultControllerClearAlgorithms(this);\n        ReadableStreamClose(stream);\n      } else {\n        ReadableStreamDefaultControllerCallPullIfNeeded(this);\n      }\n\n      readRequest._chunkSteps(chunk);\n    } else {\n      ReadableStreamAddReadRequest(stream, readRequest);\n      ReadableStreamDefaultControllerCallPullIfNeeded(this);\n    }\n  }\n\n  /** @internal */\n  [ReleaseSteps](): void {\n    // Do nothing.\n  }\n}\n\nObject.defineProperties(ReadableStreamDefaultController.prototype, {\n  close: { enumerable: true },\n  enqueue: { enumerable: true },\n  error: { enumerable: true },\n  desiredSize: { enumerable: true }\n});\nsetFunctionName(ReadableStreamDefaultController.prototype.close, 'close');\nsetFunctionName(ReadableStreamDefaultController.prototype.enqueue, 'enqueue');\nsetFunctionName(ReadableStreamDefaultController.prototype.error, 'error');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStreamDefaultController.prototype, Symbol.toStringTag, {\n    value: 'ReadableStreamDefaultController',\n    configurable: true\n  });\n}\n\n// Abstract operations for the ReadableStreamDefaultController.\n\nfunction IsReadableStreamDefaultController<R = any>(x: any): x is ReadableStreamDefaultController<R> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\n    return false;\n  }\n\n  return x instanceof ReadableStreamDefaultController;\n}\n\nfunction ReadableStreamDefaultControllerCallPullIfNeeded(controller: ReadableStreamDefaultController<any>): void {\n  const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n  if (!shouldPull) {\n    return;\n  }\n\n  if (controller._pulling) {\n    controller._pullAgain = true;\n    return;\n  }\n\n  assert(!controller._pullAgain);\n\n  controller._pulling = true;\n\n  const pullPromise = controller._pullAlgorithm();\n  uponPromise(\n    pullPromise,\n    () => {\n      controller._pulling = false;\n\n      if (controller._pullAgain) {\n        controller._pullAgain = false;\n        ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n      }\n\n      return null;\n    },\n    e => {\n      ReadableStreamDefaultControllerError(controller, e);\n      return null;\n    }\n  );\n}\n\nfunction ReadableStreamDefaultControllerShouldCallPull(controller: ReadableStreamDefaultController<any>): boolean {\n  const stream = controller._controlledReadableStream;\n\n  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n    return false;\n  }\n\n  if (!controller._started) {\n    return false;\n  }\n\n  if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n  assert(desiredSize !== null);\n  if (desiredSize! > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction ReadableStreamDefaultControllerClearAlgorithms(controller: ReadableStreamDefaultController<any>) {\n  controller._pullAlgorithm = undefined!;\n  controller._cancelAlgorithm = undefined!;\n  controller._strategySizeAlgorithm = undefined!;\n}\n\n// A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\n\nexport function ReadableStreamDefaultControllerClose(controller: ReadableStreamDefaultController<any>) {\n  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n    return;\n  }\n\n  const stream = controller._controlledReadableStream;\n\n  controller._closeRequested = true;\n\n  if (controller._queue.length === 0) {\n    ReadableStreamDefaultControllerClearAlgorithms(controller);\n    ReadableStreamClose(stream);\n  }\n}\n\nexport function ReadableStreamDefaultControllerEnqueue<R>(\n  controller: ReadableStreamDefaultController<R>,\n  chunk: R\n): void {\n  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n    return;\n  }\n\n  const stream = controller._controlledReadableStream;\n\n  if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n    ReadableStreamFulfillReadRequest(stream, chunk, false);\n  } else {\n    let chunkSize;\n    try {\n      chunkSize = controller._strategySizeAlgorithm(chunk);\n    } catch (chunkSizeE) {\n      ReadableStreamDefaultControllerError(controller, chunkSizeE);\n      throw chunkSizeE;\n    }\n\n    try {\n      EnqueueValueWithSize(controller, chunk, chunkSize);\n    } catch (enqueueE) {\n      ReadableStreamDefaultControllerError(controller, enqueueE);\n      throw enqueueE;\n    }\n  }\n\n  ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n}\n\nexport function ReadableStreamDefaultControllerError(controller: ReadableStreamDefaultController<any>, e: any) {\n  const stream = controller._controlledReadableStream;\n\n  if (stream._state !== 'readable') {\n    return;\n  }\n\n  ResetQueue(controller);\n\n  ReadableStreamDefaultControllerClearAlgorithms(controller);\n  ReadableStreamError(stream, e);\n}\n\nexport function ReadableStreamDefaultControllerGetDesiredSize(\n  controller: ReadableStreamDefaultController<any>\n): number | null {\n  const state = controller._controlledReadableStream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\n// This is used in the implementation of TransformStream.\nexport function ReadableStreamDefaultControllerHasBackpressure(\n  controller: ReadableStreamDefaultController<any>\n): boolean {\n  if (ReadableStreamDefaultControllerShouldCallPull(controller)) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function ReadableStreamDefaultControllerCanCloseOrEnqueue(\n  controller: ReadableStreamDefaultController<any>\n): boolean {\n  const state = controller._controlledReadableStream._state;\n\n  if (!controller._closeRequested && state === 'readable') {\n    return true;\n  }\n\n  return false;\n}\n\nexport function SetUpReadableStreamDefaultController<R>(stream: ReadableStream<R>,\n                                                        controller: ReadableStreamDefaultController<R>,\n                                                        startAlgorithm: () => void | PromiseLike<void>,\n                                                        pullAlgorithm: () => Promise<void>,\n                                                        cancelAlgorithm: (reason: any) => Promise<void>,\n                                                        highWaterMark: number,\n                                                        sizeAlgorithm: QueuingStrategySizeCallback<R>) {\n  assert(stream._readableStreamController === undefined);\n\n  controller._controlledReadableStream = stream;\n\n  controller._queue = undefined!;\n  controller._queueTotalSize = undefined!;\n  ResetQueue(controller);\n\n  controller._started = false;\n  controller._closeRequested = false;\n  controller._pullAgain = false;\n  controller._pulling = false;\n\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n\n  stream._readableStreamController = controller;\n\n  const startResult = startAlgorithm();\n  uponPromise(\n    promiseResolvedWith(startResult),\n    () => {\n      controller._started = true;\n\n      assert(!controller._pulling);\n      assert(!controller._pullAgain);\n\n      ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n      return null;\n    },\n    r => {\n      ReadableStreamDefaultControllerError(controller, r);\n      return null;\n    }\n  );\n}\n\nexport function SetUpReadableStreamDefaultControllerFromUnderlyingSource<R>(\n  stream: ReadableStream<R>,\n  underlyingSource: ValidatedUnderlyingSource<R>,\n  highWaterMark: number,\n  sizeAlgorithm: QueuingStrategySizeCallback<R>\n) {\n  const controller: ReadableStreamDefaultController<R> = Object.create(ReadableStreamDefaultController.prototype);\n\n  let startAlgorithm: () => void | PromiseLike<void>;\n  let pullAlgorithm: () => Promise<void>;\n  let cancelAlgorithm: (reason: any) => Promise<void>;\n\n  if (underlyingSource.start !== undefined) {\n    startAlgorithm = () => underlyingSource.start!(controller);\n  } else {\n    startAlgorithm = () => undefined;\n  }\n  if (underlyingSource.pull !== undefined) {\n    pullAlgorithm = () => underlyingSource.pull!(controller);\n  } else {\n    pullAlgorithm = () => promiseResolvedWith(undefined);\n  }\n  if (underlyingSource.cancel !== undefined) {\n    cancelAlgorithm = reason => underlyingSource.cancel!(reason);\n  } else {\n    cancelAlgorithm = () => promiseResolvedWith(undefined);\n  }\n\n  SetUpReadableStreamDefaultController(\n    stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm\n  );\n}\n\n// Helper functions for the ReadableStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n}\n", "import {\n  CreateReadableByteStream,\n  CreateReadableStream,\n  type DefaultReadableStream,\n  IsReadableStream,\n  type ReadableByteStream,\n  ReadableStream,\n  ReadableStreamCancel,\n  type ReadableStreamReader\n} from '../readable-stream';\nimport { ReadableStreamReaderGenericRelease } from './generic-reader';\nimport {\n  AcquireReadableStreamDefaultReader,\n  IsReadableStreamDefaultReader,\n  ReadableStreamDefaultReaderRead,\n  type ReadRequest\n} from './default-reader';\nimport {\n  AcquireReadableStreamBYOBReader,\n  IsReadableStreamBYOBReader,\n  ReadableStreamBYOBReaderRead,\n  type ReadIntoRequest\n} from './byob-reader';\nimport assert from '../../stub/assert';\nimport { newPromise, promiseResolvedWith, queueMicrotask, uponRejection } from '../helpers/webidl';\nimport {\n  ReadableStreamDefaultControllerClose,\n  ReadableStreamDefaultControllerEnqueue,\n  ReadableStreamDefaultControllerError\n} from './default-controller';\nimport {\n  IsReadableByteStreamController,\n  ReadableByteStreamControllerClose,\n  ReadableByteStreamControllerEnqueue,\n  ReadableByteStreamControllerError,\n  ReadableByteStreamControllerGetBYOBRequest,\n  ReadableByteStreamControllerRespond,\n  ReadableByteStreamControllerRespondWithNewView\n} from './byte-stream-controller';\nimport { CreateArrayFromList } from '../abstract-ops/ecmascript';\nimport { CloneAsUint8Array } from '../abstract-ops/miscellaneous';\nimport type { NonShared } from '../helpers/array-buffer-view';\n\nexport function ReadableStreamTee<R>(stream: ReadableStream<R>,\n                                     cloneForBranch2: boolean): [ReadableStream<R>, ReadableStream<R>] {\n  assert(IsReadableStream(stream));\n  assert(typeof cloneForBranch2 === 'boolean');\n  if (IsReadableByteStreamController(stream._readableStreamController)) {\n    return ReadableByteStreamTee(stream as unknown as ReadableByteStream) as\n      unknown as [ReadableStream<R>, ReadableStream<R>];\n  }\n  return ReadableStreamDefaultTee(stream, cloneForBranch2);\n}\n\nexport function ReadableStreamDefaultTee<R>(\n  stream: ReadableStream<R>,\n  cloneForBranch2: boolean\n): [DefaultReadableStream<R>, DefaultReadableStream<R>] {\n  assert(IsReadableStream(stream));\n  assert(typeof cloneForBranch2 === 'boolean');\n\n  const reader = AcquireReadableStreamDefaultReader<R>(stream);\n\n  let reading = false;\n  let readAgain = false;\n  let canceled1 = false;\n  let canceled2 = false;\n  let reason1: any;\n  let reason2: any;\n  let branch1: DefaultReadableStream<R>;\n  let branch2: DefaultReadableStream<R>;\n\n  let resolveCancelPromise: (value: undefined | Promise<undefined>) => void;\n  const cancelPromise = newPromise<undefined>(resolve => {\n    resolveCancelPromise = resolve;\n  });\n\n  function pullAlgorithm(): Promise<void> {\n    if (reading) {\n      readAgain = true;\n      return promiseResolvedWith(undefined);\n    }\n\n    reading = true;\n\n    const readRequest: ReadRequest<R> = {\n      _chunkSteps: chunk => {\n        // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n        // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n        // successful synchronously-available reads get ahead of asynchronously-available errors.\n        queueMicrotask(() => {\n          readAgain = false;\n          const chunk1 = chunk;\n          const chunk2 = chunk;\n\n          // There is no way to access the cloning code right now in the reference implementation.\n          // If we add one then we'll need an implementation for serializable objects.\n          // if (!canceled2 && cloneForBranch2) {\n          //   chunk2 = StructuredDeserialize(StructuredSerialize(chunk2));\n          // }\n\n          if (!canceled1) {\n            ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);\n          }\n          if (!canceled2) {\n            ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);\n          }\n\n          reading = false;\n          if (readAgain) {\n            pullAlgorithm();\n          }\n        });\n      },\n      _closeSteps: () => {\n        reading = false;\n        if (!canceled1) {\n          ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n        }\n        if (!canceled2) {\n          ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n        }\n\n        if (!canceled1 || !canceled2) {\n          resolveCancelPromise(undefined);\n        }\n      },\n      _errorSteps: () => {\n        reading = false;\n      }\n    };\n    ReadableStreamDefaultReaderRead(reader, readRequest);\n\n    return promiseResolvedWith(undefined);\n  }\n\n  function cancel1Algorithm(reason: any): Promise<void> {\n    canceled1 = true;\n    reason1 = reason;\n    if (canceled2) {\n      const compositeReason = CreateArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function cancel2Algorithm(reason: any): Promise<void> {\n    canceled2 = true;\n    reason2 = reason;\n    if (canceled1) {\n      const compositeReason = CreateArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function startAlgorithm() {\n    // do nothing\n  }\n\n  branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n  branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n\n  uponRejection(reader._closedPromise, (r: any) => {\n    ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n    ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n    if (!canceled1 || !canceled2) {\n      resolveCancelPromise(undefined);\n    }\n    return null;\n  });\n\n  return [branch1, branch2];\n}\n\nexport function ReadableByteStreamTee(stream: ReadableByteStream): [ReadableByteStream, ReadableByteStream] {\n  assert(IsReadableStream(stream));\n  assert(IsReadableByteStreamController(stream._readableStreamController));\n\n  let reader: ReadableStreamReader<NonShared<Uint8Array>> = AcquireReadableStreamDefaultReader(stream);\n  let reading = false;\n  let readAgainForBranch1 = false;\n  let readAgainForBranch2 = false;\n  let canceled1 = false;\n  let canceled2 = false;\n  let reason1: any;\n  let reason2: any;\n  let branch1: ReadableByteStream;\n  let branch2: ReadableByteStream;\n\n  let resolveCancelPromise: (value: undefined | Promise<undefined>) => void;\n  const cancelPromise = newPromise<void>(resolve => {\n    resolveCancelPromise = resolve;\n  });\n\n  function forwardReaderError(thisReader: ReadableStreamReader<NonShared<Uint8Array>>) {\n    uponRejection(thisReader._closedPromise, r => {\n      if (thisReader !== reader) {\n        return null;\n      }\n      ReadableByteStreamControllerError(branch1._readableStreamController, r);\n      ReadableByteStreamControllerError(branch2._readableStreamController, r);\n      if (!canceled1 || !canceled2) {\n        resolveCancelPromise(undefined);\n      }\n      return null;\n    });\n  }\n\n  function pullWithDefaultReader() {\n    if (IsReadableStreamBYOBReader(reader)) {\n      assert(reader._readIntoRequests.length === 0);\n      ReadableStreamReaderGenericRelease(reader);\n\n      reader = AcquireReadableStreamDefaultReader(stream);\n      forwardReaderError(reader);\n    }\n\n    const readRequest: ReadRequest<NonShared<Uint8Array>> = {\n      _chunkSteps: chunk => {\n        // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n        // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n        // successful synchronously-available reads get ahead of asynchronously-available errors.\n        queueMicrotask(() => {\n          readAgainForBranch1 = false;\n          readAgainForBranch2 = false;\n\n          const chunk1 = chunk;\n          let chunk2 = chunk;\n          if (!canceled1 && !canceled2) {\n            try {\n              chunk2 = CloneAsUint8Array(chunk);\n            } catch (cloneE) {\n              ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);\n              ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);\n              resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n              return;\n            }\n          }\n\n          if (!canceled1) {\n            ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);\n          }\n          if (!canceled2) {\n            ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);\n          }\n\n          reading = false;\n          if (readAgainForBranch1) {\n            pull1Algorithm();\n          } else if (readAgainForBranch2) {\n            pull2Algorithm();\n          }\n        });\n      },\n      _closeSteps: () => {\n        reading = false;\n        if (!canceled1) {\n          ReadableByteStreamControllerClose(branch1._readableStreamController);\n        }\n        if (!canceled2) {\n          ReadableByteStreamControllerClose(branch2._readableStreamController);\n        }\n        if (branch1._readableStreamController._pendingPullIntos.length > 0) {\n          ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);\n        }\n        if (branch2._readableStreamController._pendingPullIntos.length > 0) {\n          ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);\n        }\n        if (!canceled1 || !canceled2) {\n          resolveCancelPromise(undefined);\n        }\n      },\n      _errorSteps: () => {\n        reading = false;\n      }\n    };\n    ReadableStreamDefaultReaderRead(reader, readRequest);\n  }\n\n  function pullWithBYOBReader(view: NonShared<ArrayBufferView>, forBranch2: boolean) {\n    if (IsReadableStreamDefaultReader<NonShared<Uint8Array>>(reader)) {\n      assert(reader._readRequests.length === 0);\n      ReadableStreamReaderGenericRelease(reader);\n\n      reader = AcquireReadableStreamBYOBReader(stream);\n      forwardReaderError(reader);\n    }\n\n    const byobBranch = forBranch2 ? branch2 : branch1;\n    const otherBranch = forBranch2 ? branch1 : branch2;\n\n    const readIntoRequest: ReadIntoRequest<NonShared<ArrayBufferView>> = {\n      _chunkSteps: chunk => {\n        // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n        // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n        // successful synchronously-available reads get ahead of asynchronously-available errors.\n        queueMicrotask(() => {\n          readAgainForBranch1 = false;\n          readAgainForBranch2 = false;\n\n          const byobCanceled = forBranch2 ? canceled2 : canceled1;\n          const otherCanceled = forBranch2 ? canceled1 : canceled2;\n\n          if (!otherCanceled) {\n            let clonedChunk;\n            try {\n              clonedChunk = CloneAsUint8Array(chunk);\n            } catch (cloneE) {\n              ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);\n              ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);\n              resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n              return;\n            }\n            if (!byobCanceled) {\n              ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n            }\n            ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);\n          } else if (!byobCanceled) {\n            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n          }\n\n          reading = false;\n          if (readAgainForBranch1) {\n            pull1Algorithm();\n          } else if (readAgainForBranch2) {\n            pull2Algorithm();\n          }\n        });\n      },\n      _closeSteps: chunk => {\n        reading = false;\n\n        const byobCanceled = forBranch2 ? canceled2 : canceled1;\n        const otherCanceled = forBranch2 ? canceled1 : canceled2;\n\n        if (!byobCanceled) {\n          ReadableByteStreamControllerClose(byobBranch._readableStreamController);\n        }\n        if (!otherCanceled) {\n          ReadableByteStreamControllerClose(otherBranch._readableStreamController);\n        }\n\n        if (chunk !== undefined) {\n          assert(chunk.byteLength === 0);\n\n          if (!byobCanceled) {\n            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n          }\n          if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {\n            ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);\n          }\n        }\n\n        if (!byobCanceled || !otherCanceled) {\n          resolveCancelPromise(undefined);\n        }\n      },\n      _errorSteps: () => {\n        reading = false;\n      }\n    };\n    ReadableStreamBYOBReaderRead(reader, view, 1, readIntoRequest);\n  }\n\n  function pull1Algorithm(): Promise<void> {\n    if (reading) {\n      readAgainForBranch1 = true;\n      return promiseResolvedWith(undefined);\n    }\n\n    reading = true;\n\n    const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);\n    if (byobRequest === null) {\n      pullWithDefaultReader();\n    } else {\n      pullWithBYOBReader(byobRequest._view!, false);\n    }\n\n    return promiseResolvedWith(undefined);\n  }\n\n  function pull2Algorithm(): Promise<void> {\n    if (reading) {\n      readAgainForBranch2 = true;\n      return promiseResolvedWith(undefined);\n    }\n\n    reading = true;\n\n    const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);\n    if (byobRequest === null) {\n      pullWithDefaultReader();\n    } else {\n      pullWithBYOBReader(byobRequest._view!, true);\n    }\n\n    return promiseResolvedWith(undefined);\n  }\n\n  function cancel1Algorithm(reason: any): Promise<void> {\n    canceled1 = true;\n    reason1 = reason;\n    if (canceled2) {\n      const compositeReason = CreateArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function cancel2Algorithm(reason: any): Promise<void> {\n    canceled2 = true;\n    reason2 = reason;\n    if (canceled1) {\n      const compositeReason = CreateArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function startAlgorithm(): void {\n    return;\n  }\n\n  branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);\n  branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);\n\n  forwardReaderError(reader);\n\n  return [branch1, branch2];\n}\n", "import { typeIsObject } from '../helpers/miscellaneous';\nimport type { ReadableStreamDefaultReadResult } from './default-reader';\n\n/**\n * A common interface for a `ReadadableStream` implementation.\n *\n * @public\n */\nexport interface ReadableStreamLike<R = any> {\n  readonly locked: boolean;\n\n  getReader(): ReadableStreamDefaultReaderLike<R>;\n}\n\n/**\n * A common interface for a `ReadableStreamDefaultReader` implementation.\n *\n * @public\n */\nexport interface ReadableStreamDefaultReaderLike<R = any> {\n  readonly closed: Promise<undefined>;\n\n  cancel(reason?: any): Promise<void>;\n\n  read(): Promise<ReadableStreamDefaultReadResult<R>>;\n\n  releaseLock(): void;\n}\n\nexport function isReadableStreamLike<R>(stream: unknown): stream is ReadableStreamLike<R> {\n  return typeIsObject(stream) && typeof (stream as ReadableStreamLike<R>).getReader !== 'undefined';\n}\n", "import { CreateReadableStream, type DefaultReadableStream } from '../readable-stream';\nimport {\n  isReadableStreamLike,\n  type ReadableStreamDefaultReaderLike,\n  type ReadableStreamLike\n} from './readable-stream-like';\nimport { ReadableStreamDefaultControllerClose, ReadableStreamDefaultControllerEnqueue } from './default-controller';\nimport { GetIterator, GetMethod, IteratorComplete, IteratorNext, IteratorValue } from '../abstract-ops/ecmascript';\nimport { promiseRejectedWith, promiseResolvedWith, reflectCall, transformPromiseWith } from '../helpers/webidl';\nimport { typeIsObject } from '../helpers/miscellaneous';\nimport { noop } from '../../utils';\n\nexport function ReadableStreamFrom<R>(\n  source: Iterable<R> | AsyncIterable<R> | ReadableStreamLike<R>\n): DefaultReadableStream<R> {\n  if (isReadableStreamLike(source)) {\n    return ReadableStreamFromDefaultReader(source.getReader());\n  }\n  return ReadableStreamFromIterable(source);\n}\n\nexport function ReadableStreamFromIterable<R>(asyncIterable: Iterable<R> | AsyncIterable<R>): DefaultReadableStream<R> {\n  let stream: DefaultReadableStream<R>;\n  const iteratorRecord = GetIterator(asyncIterable, 'async');\n\n  const startAlgorithm = noop;\n\n  function pullAlgorithm(): Promise<void> {\n    let nextResult;\n    try {\n      nextResult = IteratorNext(iteratorRecord);\n    } catch (e) {\n      return promiseRejectedWith(e);\n    }\n    const nextPromise = promiseResolvedWith(nextResult);\n    return transformPromiseWith(nextPromise, iterResult => {\n      if (!typeIsObject(iterResult)) {\n        throw new TypeError('The promise returned by the iterator.next() method must fulfill with an object');\n      }\n      const done = IteratorComplete(iterResult);\n      if (done) {\n        ReadableStreamDefaultControllerClose(stream._readableStreamController);\n      } else {\n        const value = IteratorValue(iterResult);\n        ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);\n      }\n    });\n  }\n\n  function cancelAlgorithm(reason: any): Promise<void> {\n    const iterator = iteratorRecord.iterator;\n    let returnMethod: (typeof iterator)['return'] | undefined;\n    try {\n      returnMethod = GetMethod(iterator, 'return');\n    } catch (e) {\n      return promiseRejectedWith(e);\n    }\n    if (returnMethod === undefined) {\n      return promiseResolvedWith(undefined);\n    }\n    let returnResult: IteratorResult<R> | Promise<IteratorResult<R>>;\n    try {\n      returnResult = reflectCall(returnMethod, iterator, [reason]);\n    } catch (e) {\n      return promiseRejectedWith(e);\n    }\n    const returnPromise = promiseResolvedWith(returnResult);\n    return transformPromiseWith(returnPromise, iterResult => {\n      if (!typeIsObject(iterResult)) {\n        throw new TypeError('The promise returned by the iterator.return() method must fulfill with an object');\n      }\n      return undefined;\n    });\n  }\n\n  stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);\n  return stream;\n}\n\nexport function ReadableStreamFromDefaultReader<R>(\n  reader: ReadableStreamDefaultReaderLike<R>\n): DefaultReadableStream<R> {\n  let stream: DefaultReadableStream<R>;\n\n  const startAlgorithm = noop;\n\n  function pullAlgorithm(): Promise<void> {\n    let readPromise;\n    try {\n      readPromise = reader.read();\n    } catch (e) {\n      return promiseRejectedWith(e);\n    }\n    return transformPromiseWith(readPromise, readResult => {\n      if (!typeIsObject(readResult)) {\n        throw new TypeError('The promise returned by the reader.read() method must fulfill with an object');\n      }\n      if (readResult.done) {\n        ReadableStreamDefaultControllerClose(stream._readableStreamController);\n      } else {\n        const value = readResult.value;\n        ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);\n      }\n    });\n  }\n\n  function cancelAlgorithm(reason: any): Promise<void> {\n    try {\n      return promiseResolvedWith(reader.cancel(reason));\n    } catch (e) {\n      return promiseRejectedWith(e);\n    }\n  }\n\n  stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);\n  return stream;\n}\n", "import { assertDictionary, assertFunction, convertUnsignedLongLongWithEnforceRange } from './basic';\nimport type {\n  ReadableStreamController,\n  UnderlyingByteSource,\n  UnderlyingDefaultOrByteSource,\n  UnderlyingDefaultOrByteSourcePullCallback,\n  UnderlyingDefaultOrByteSourceStartCallback,\n  UnderlyingSource,\n  UnderlyingSourceCancelCallback,\n  ValidatedUnderlyingDefaultOrByteSource\n} from '../readable-stream/underlying-source';\nimport { promiseCall, reflectCall } from '../helpers/webidl';\n\nexport function convertUnderlyingDefaultOrByteSource<R>(\n  source: UnderlyingSource<R> | UnderlyingByteSource | null,\n  context: string\n): ValidatedUnderlyingDefaultOrByteSource<R> {\n  assertDictionary(source, context);\n  const original = source as (UnderlyingDefaultOrByteSource<R> | null);\n  const autoAllocateChunkSize = original?.autoAllocateChunkSize;\n  const cancel = original?.cancel;\n  const pull = original?.pull;\n  const start = original?.start;\n  const type = original?.type;\n  return {\n    autoAllocateChunkSize: autoAllocateChunkSize === undefined ?\n      undefined :\n      convertUnsignedLongLongWithEnforceRange(\n        autoAllocateChunkSize,\n        `${context} has member 'autoAllocateChunkSize' that`\n      ),\n    cancel: cancel === undefined ?\n      undefined :\n      convertUnderlyingSourceCancelCallback(cancel, original!, `${context} has member 'cancel' that`),\n    pull: pull === undefined ?\n      undefined :\n      convertUnderlyingSourcePullCallback(pull, original!, `${context} has member 'pull' that`),\n    start: start === undefined ?\n      undefined :\n      convertUnderlyingSourceStartCallback(start, original!, `${context} has member 'start' that`),\n    type: type === undefined ? undefined : convertReadableStreamType(type, `${context} has member 'type' that`)\n  };\n}\n\nfunction convertUnderlyingSourceCancelCallback(\n  fn: UnderlyingSourceCancelCallback,\n  original: UnderlyingDefaultOrByteSource,\n  context: string\n): (reason: any) => Promise<void> {\n  assertFunction(fn, context);\n  return (reason: any) => promiseCall(fn, original, [reason]);\n}\n\nfunction convertUnderlyingSourcePullCallback<R>(\n  fn: UnderlyingDefaultOrByteSourcePullCallback<R>,\n  original: UnderlyingDefaultOrByteSource<R>,\n  context: string\n): (controller: ReadableStreamController<R>) => Promise<void> {\n  assertFunction(fn, context);\n  return (controller: ReadableStreamController<R>) => promiseCall(fn, original, [controller]);\n}\n\nfunction convertUnderlyingSourceStartCallback<R>(\n  fn: UnderlyingDefaultOrByteSourceStartCallback<R>,\n  original: UnderlyingDefaultOrByteSource<R>,\n  context: string\n): UnderlyingDefaultOrByteSourceStartCallback<R> {\n  assertFunction(fn, context);\n  return (controller: ReadableStreamController<R>) => reflectCall(fn, original, [controller]);\n}\n\nfunction convertReadableStreamType(type: string, context: string): 'bytes' {\n  type = `${type}`;\n  if (type !== 'bytes') {\n    throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);\n  }\n  return type;\n}\n", "import { assertDictionary } from './basic';\nimport type {\n  ReadableStreamIteratorOptions,\n  ValidatedReadableStreamIteratorOptions\n} from '../readable-stream/iterator-options';\n\nexport function convertIteratorOptions(options: ReadableStreamIteratorOptions | null | undefined,\n                                       context: string): ValidatedReadableStreamIteratorOptions {\n  assertDictionary(options, context);\n  const preventCancel = options?.preventCancel;\n  return { preventCancel: Boolean(preventCancel) };\n}\n", "import { assertDictionary } from './basic';\nimport type { StreamPipeOptions, ValidatedStreamPipeOptions } from '../readable-stream/pipe-options';\nimport { type AbortSignal, isAbortSignal } from '../abort-signal';\n\nexport function convertPipeOptions(options: StreamPipeOptions | null | undefined,\n                                   context: string): ValidatedStreamPipeOptions {\n  assertDictionary(options, context);\n  const preventAbort = options?.preventAbort;\n  const preventCancel = options?.preventCancel;\n  const preventClose = options?.preventClose;\n  const signal = options?.signal;\n  if (signal !== undefined) {\n    assertAbortSignal(signal, `${context} has member 'signal' that`);\n  }\n  return {\n    preventAbort: Boolean(preventAbort),\n    preventCancel: Boolean(preventCancel),\n    preventClose: Boolean(preventClose),\n    signal\n  };\n}\n\nfunction assertAbortSignal(signal: unknown, context: string): asserts signal is AbortSignal {\n  if (!isAbortSignal(signal)) {\n    throw new TypeError(`${context} is not an AbortSignal.`);\n  }\n}\n", "import { assertDictionary, assertRequiredField } from './basic';\nimport { ReadableStream } from '../readable-stream';\nimport { WritableStream } from '../writable-stream';\nimport { assertReadableStream } from './readable-stream';\nimport { assertWritableStream } from './writable-stream';\n\nexport function convertReadableWritablePair<RS extends ReadableStream, WS extends WritableStream>(\n  pair: { readable: RS; writable: WS } | null | undefined,\n  context: string\n): { readable: RS; writable: WS } {\n  assertDictionary(pair, context);\n\n  const readable = pair?.readable;\n  assertRequiredField(readable, 'readable', 'ReadableWritablePair');\n  assertReadableStream(readable, `${context} has member 'readable' that`);\n\n  const writable = pair?.writable;\n  assertRequiredField(writable, 'writable', 'ReadableWritablePair');\n  assertWritableStream(writable, `${context} has member 'writable' that`);\n\n  return { readable, writable };\n}\n", "import assert from '../stub/assert';\nimport {\n  promiseRejectedWith,\n  promiseResolvedWith,\n  setPromiseIsHandledToTrue,\n  transformPromiseWith\n} from './helpers/webidl';\nimport type { QueuingStrategy, QueuingStrategySizeCallback } from './queuing-strategy';\nimport { AcquireReadableStreamAsyncIterator, type ReadableStreamAsyncIterator } from './readable-stream/async-iterator';\nimport { defaultReaderClosedPromiseReject, defaultReaderClosedPromiseResolve } from './readable-stream/generic-reader';\nimport {\n  AcquireReadableStreamDefaultReader,\n  IsReadableStreamDefaultReader,\n  ReadableStreamDefaultReader,\n  ReadableStreamDefaultReaderErrorReadRequests,\n  type ReadableStreamDefaultReadResult\n} from './readable-stream/default-reader';\nimport {\n  AcquireReadableStreamBYOBReader,\n  IsReadableStreamBYOBReader,\n  ReadableStreamBYOBReader,\n  ReadableStreamBYOBReaderErrorReadIntoRequests,\n  type ReadableStreamBYOBReadResult\n} from './readable-stream/byob-reader';\nimport { ReadableStreamPipeTo } from './readable-stream/pipe';\nimport { ReadableStreamTee } from './readable-stream/tee';\nimport { ReadableStreamFrom } from './readable-stream/from';\nimport { IsWritableStream, IsWritableStreamLocked, WritableStream } from './writable-stream';\nimport { SimpleQueue } from './simple-queue';\nimport {\n  ReadableByteStreamController,\n  ReadableStreamBYOBRequest,\n  SetUpReadableByteStreamController,\n  SetUpReadableByteStreamControllerFromUnderlyingSource\n} from './readable-stream/byte-stream-controller';\nimport {\n  ReadableStreamDefaultController,\n  SetUpReadableStreamDefaultController,\n  SetUpReadableStreamDefaultControllerFromUnderlyingSource\n} from './readable-stream/default-controller';\nimport type {\n  UnderlyingByteSource,\n  UnderlyingByteSourcePullCallback,\n  UnderlyingByteSourceStartCallback,\n  UnderlyingSource,\n  UnderlyingSourceCancelCallback,\n  UnderlyingSourcePullCallback,\n  UnderlyingSourceStartCallback\n} from './readable-stream/underlying-source';\nimport { noop } from '../utils';\nimport { setFunctionName, typeIsObject } from './helpers/miscellaneous';\nimport { CreateArrayFromList, SymbolAsyncIterator } from './abstract-ops/ecmascript';\nimport { CancelSteps } from './abstract-ops/internal-methods';\nimport { IsNonNegativeNumber } from './abstract-ops/miscellaneous';\nimport { assertObject, assertRequiredArgument } from './validators/basic';\nimport { convertQueuingStrategy } from './validators/queuing-strategy';\nimport { ExtractHighWaterMark, ExtractSizeAlgorithm } from './abstract-ops/queuing-strategy';\nimport { convertUnderlyingDefaultOrByteSource } from './validators/underlying-source';\nimport type {\n  ReadableStreamBYOBReaderReadOptions,\n  ReadableStreamGetReaderOptions\n} from './readable-stream/reader-options';\nimport { convertReaderOptions } from './validators/reader-options';\nimport type { StreamPipeOptions, ValidatedStreamPipeOptions } from './readable-stream/pipe-options';\nimport type { ReadableStreamIteratorOptions } from './readable-stream/iterator-options';\nimport { convertIteratorOptions } from './validators/iterator-options';\nimport { convertPipeOptions } from './validators/pipe-options';\nimport type { ReadableWritablePair } from './readable-stream/readable-writable-pair';\nimport { convertReadableWritablePair } from './validators/readable-writable-pair';\nimport type { ReadableStreamDefaultReaderLike, ReadableStreamLike } from './readable-stream/readable-stream-like';\nimport type { NonShared } from './helpers/array-buffer-view';\n\nexport type DefaultReadableStream<R = any> = ReadableStream<R> & {\n  _readableStreamController: ReadableStreamDefaultController<R>\n};\n\nexport type ReadableByteStream = ReadableStream<NonShared<Uint8Array>> & {\n  _readableStreamController: ReadableByteStreamController\n};\n\ntype ReadableStreamState = 'readable' | 'closed' | 'errored';\n\n/**\n * A readable stream represents a source of data, from which you can read.\n *\n * @public\n */\nexport class ReadableStream<R = any> implements AsyncIterable<R> {\n  /** @internal */\n  _state!: ReadableStreamState;\n  /** @internal */\n  _reader: ReadableStreamReader<R> | undefined;\n  /** @internal */\n  _storedError: any;\n  /** @internal */\n  _disturbed!: boolean;\n  /** @internal */\n  _readableStreamController!: ReadableStreamDefaultController<R> | ReadableByteStreamController;\n\n  constructor(underlyingSource: UnderlyingByteSource, strategy?: { highWaterMark?: number; size?: undefined });\n  constructor(underlyingSource?: UnderlyingSource<R>, strategy?: QueuingStrategy<R>);\n  constructor(rawUnderlyingSource: UnderlyingSource<R> | UnderlyingByteSource | null | undefined = {},\n              rawStrategy: QueuingStrategy<R> | null | undefined = {}) {\n    if (rawUnderlyingSource === undefined) {\n      rawUnderlyingSource = null;\n    } else {\n      assertObject(rawUnderlyingSource, 'First parameter');\n    }\n\n    const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n    const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, 'First parameter');\n\n    InitializeReadableStream(this);\n\n    if (underlyingSource.type === 'bytes') {\n      if (strategy.size !== undefined) {\n        throw new RangeError('The strategy for a byte stream cannot have a size function');\n      }\n      const highWaterMark = ExtractHighWaterMark(strategy, 0);\n      SetUpReadableByteStreamControllerFromUnderlyingSource(\n        this as unknown as ReadableByteStream,\n        underlyingSource,\n        highWaterMark\n      );\n    } else {\n      assert(underlyingSource.type === undefined);\n      const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n      const highWaterMark = ExtractHighWaterMark(strategy, 1);\n      SetUpReadableStreamDefaultControllerFromUnderlyingSource(\n        this,\n        underlyingSource,\n        highWaterMark,\n        sizeAlgorithm\n      );\n    }\n  }\n\n  /**\n   * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\n   */\n  get locked(): boolean {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('locked');\n    }\n\n    return IsReadableStreamLocked(this);\n  }\n\n  /**\n   * Cancels the stream, signaling a loss of interest in the stream by a consumer.\n   *\n   * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}\n   * method, which might or might not use it.\n   */\n  cancel(reason: any = undefined): Promise<void> {\n    if (!IsReadableStream(this)) {\n      return promiseRejectedWith(streamBrandCheckException('cancel'));\n    }\n\n    if (IsReadableStreamLocked(this)) {\n      return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));\n    }\n\n    return ReadableStreamCancel(this, reason);\n  }\n\n  /**\n   * Creates a {@link ReadableStreamBYOBReader} and locks the stream to the new reader.\n   *\n   * This call behaves the same way as the no-argument variant, except that it only works on readable byte streams,\n   * i.e. streams which were constructed specifically with the ability to handle \"bring your own buffer\" reading.\n   * The returned BYOB reader provides the ability to directly read individual chunks from the stream via its\n   * {@link ReadableStreamBYOBReader.read | read()} method, into developer-supplied buffers, allowing more precise\n   * control over allocation.\n   */\n  getReader({ mode }: { mode: 'byob' }): ReadableStreamBYOBReader;\n  /**\n   * Creates a {@link ReadableStreamDefaultReader} and locks the stream to the new reader.\n   * While the stream is locked, no other reader can be acquired until this one is released.\n   *\n   * This functionality is especially useful for creating abstractions that desire the ability to consume a stream\n   * in its entirety. By getting a reader for the stream, you can ensure nobody else can interleave reads with yours\n   * or cancel the stream, which would interfere with your abstraction.\n   */\n  getReader(): ReadableStreamDefaultReader<R>;\n  getReader(\n    rawOptions: ReadableStreamGetReaderOptions | null | undefined = undefined\n  ): ReadableStreamDefaultReader<R> | ReadableStreamBYOBReader {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('getReader');\n    }\n\n    const options = convertReaderOptions(rawOptions, 'First parameter');\n\n    if (options.mode === undefined) {\n      return AcquireReadableStreamDefaultReader(this);\n    }\n\n    assert(options.mode === 'byob');\n    return AcquireReadableStreamBYOBReader(this as unknown as ReadableByteStream);\n  }\n\n  /**\n   * Provides a convenient, chainable way of piping this readable stream through a transform stream\n   * (or any other `{ writable, readable }` pair). It simply {@link ReadableStream.pipeTo | pipes} the stream\n   * into the writable side of the supplied pair, and returns the readable side for further use.\n   *\n   * Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.\n   */\n  pipeThrough<RS extends ReadableStream>(\n    transform: { readable: RS; writable: WritableStream<R> },\n    options?: StreamPipeOptions\n  ): RS;\n  pipeThrough<RS extends ReadableStream>(\n    rawTransform: { readable: RS; writable: WritableStream<R> } | null | undefined,\n    rawOptions: StreamPipeOptions | null | undefined = {}\n  ): RS {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('pipeThrough');\n    }\n    assertRequiredArgument(rawTransform, 1, 'pipeThrough');\n\n    const transform = convertReadableWritablePair(rawTransform, 'First parameter');\n    const options = convertPipeOptions(rawOptions, 'Second parameter');\n\n    if (IsReadableStreamLocked(this)) {\n      throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');\n    }\n    if (IsWritableStreamLocked(transform.writable)) {\n      throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');\n    }\n\n    const promise = ReadableStreamPipeTo(\n      this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal\n    );\n\n    setPromiseIsHandledToTrue(promise);\n\n    return transform.readable;\n  }\n\n  /**\n   * Pipes this readable stream to a given writable stream. The way in which the piping process behaves under\n   * various error conditions can be customized with a number of passed options. It returns a promise that fulfills\n   * when the piping process completes successfully, or rejects if any errors were encountered.\n   *\n   * Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.\n   */\n  pipeTo(destination: WritableStream<R>, options?: StreamPipeOptions): Promise<void>;\n  pipeTo(destination: WritableStream<R> | null | undefined,\n         rawOptions: StreamPipeOptions | null | undefined = {}): Promise<void> {\n    if (!IsReadableStream(this)) {\n      return promiseRejectedWith(streamBrandCheckException('pipeTo'));\n    }\n\n    if (destination === undefined) {\n      return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);\n    }\n    if (!IsWritableStream(destination)) {\n      return promiseRejectedWith(\n        new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`)\n      );\n    }\n\n    let options: ValidatedStreamPipeOptions;\n    try {\n      options = convertPipeOptions(rawOptions, 'Second parameter');\n    } catch (e) {\n      return promiseRejectedWith(e);\n    }\n\n    if (IsReadableStreamLocked(this)) {\n      return promiseRejectedWith(\n        new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream')\n      );\n    }\n    if (IsWritableStreamLocked(destination)) {\n      return promiseRejectedWith(\n        new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream')\n      );\n    }\n\n    return ReadableStreamPipeTo<R>(\n      this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal\n    );\n  }\n\n  /**\n   * Tees this readable stream, returning a two-element array containing the two resulting branches as\n   * new {@link ReadableStream} instances.\n   *\n   * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\n   * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\n   * propagated to the stream's underlying source.\n   *\n   * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,\n   * this could allow interference between the two branches.\n   */\n  tee(): [ReadableStream<R>, ReadableStream<R>] {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('tee');\n    }\n\n    const branches = ReadableStreamTee(this, false);\n    return CreateArrayFromList(branches);\n  }\n\n  /**\n   * Asynchronously iterates over the chunks in the stream's internal queue.\n   *\n   * Asynchronously iterating over the stream will lock it, preventing any other consumer from acquiring a reader.\n   * The lock will be released if the async iterator's {@link ReadableStreamAsyncIterator.return | return()} method\n   * is called, e.g. by breaking out of the loop.\n   *\n   * By default, calling the async iterator's {@link ReadableStreamAsyncIterator.return | return()} method will also\n   * cancel the stream. To prevent this, use the stream's {@link ReadableStream.values | values()} method, passing\n   * `true` for the `preventCancel` option.\n   */\n  values(options?: ReadableStreamIteratorOptions): ReadableStreamAsyncIterator<R>;\n  values(rawOptions: ReadableStreamIteratorOptions | null | undefined = undefined): ReadableStreamAsyncIterator<R> {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('values');\n    }\n\n    const options = convertIteratorOptions(rawOptions, 'First parameter');\n    return AcquireReadableStreamAsyncIterator<R>(this, options.preventCancel);\n  }\n\n  /**\n   * {@inheritDoc ReadableStream.values}\n   */\n  [Symbol.asyncIterator](options?: ReadableStreamIteratorOptions): ReadableStreamAsyncIterator<R>;\n\n  [SymbolAsyncIterator](options?: ReadableStreamIteratorOptions): ReadableStreamAsyncIterator<R> {\n    // Stub implementation, overridden below\n    return this.values(options);\n  }\n\n  /**\n   * Creates a new ReadableStream wrapping the provided iterable or async iterable.\n   *\n   * This can be used to adapt various kinds of objects into a readable stream,\n   * such as an array, an async generator, or a Node.js readable stream.\n   */\n  static from<R>(asyncIterable: Iterable<R> | AsyncIterable<R> | ReadableStreamLike<R>): ReadableStream<R> {\n    return ReadableStreamFrom(asyncIterable);\n  }\n}\n\nObject.defineProperties(ReadableStream, {\n  from: { enumerable: true }\n});\nObject.defineProperties(ReadableStream.prototype, {\n  cancel: { enumerable: true },\n  getReader: { enumerable: true },\n  pipeThrough: { enumerable: true },\n  pipeTo: { enumerable: true },\n  tee: { enumerable: true },\n  values: { enumerable: true },\n  locked: { enumerable: true }\n});\nsetFunctionName(ReadableStream.from, 'from');\nsetFunctionName(ReadableStream.prototype.cancel, 'cancel');\nsetFunctionName(ReadableStream.prototype.getReader, 'getReader');\nsetFunctionName(ReadableStream.prototype.pipeThrough, 'pipeThrough');\nsetFunctionName(ReadableStream.prototype.pipeTo, 'pipeTo');\nsetFunctionName(ReadableStream.prototype.tee, 'tee');\nsetFunctionName(ReadableStream.prototype.values, 'values');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStream.prototype, Symbol.toStringTag, {\n    value: 'ReadableStream',\n    configurable: true\n  });\n}\nObject.defineProperty(ReadableStream.prototype, SymbolAsyncIterator, {\n  value: ReadableStream.prototype.values,\n  writable: true,\n  configurable: true\n});\n\nexport type {\n  ReadableStreamAsyncIterator,\n  ReadableStreamDefaultReadResult,\n  ReadableStreamBYOBReadResult,\n  ReadableStreamBYOBReaderReadOptions,\n  UnderlyingByteSource,\n  UnderlyingSource,\n  UnderlyingSourceStartCallback,\n  UnderlyingSourcePullCallback,\n  UnderlyingSourceCancelCallback,\n  UnderlyingByteSourceStartCallback,\n  UnderlyingByteSourcePullCallback,\n  StreamPipeOptions,\n  ReadableWritablePair,\n  ReadableStreamIteratorOptions,\n  ReadableStreamLike,\n  ReadableStreamDefaultReaderLike\n};\n\n// Abstract operations for the ReadableStream.\n\n// Throws if and only if startAlgorithm throws.\nexport function CreateReadableStream<R>(\n  startAlgorithm: () => void | PromiseLike<void>,\n  pullAlgorithm: () => Promise<void>,\n  cancelAlgorithm: (reason: any) => Promise<void>,\n  highWaterMark = 1,\n  sizeAlgorithm: QueuingStrategySizeCallback<R> = () => 1\n): DefaultReadableStream<R> {\n  assert(IsNonNegativeNumber(highWaterMark));\n\n  const stream: DefaultReadableStream<R> = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n\n  const controller: ReadableStreamDefaultController<R> = Object.create(ReadableStreamDefaultController.prototype);\n  SetUpReadableStreamDefaultController(\n    stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm\n  );\n\n  return stream;\n}\n\n// Throws if and only if startAlgorithm throws.\nexport function CreateReadableByteStream(\n  startAlgorithm: () => void | PromiseLike<void>,\n  pullAlgorithm: () => Promise<void>,\n  cancelAlgorithm: (reason: any) => Promise<void>\n): ReadableByteStream {\n  const stream: ReadableByteStream = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n\n  const controller: ReadableByteStreamController = Object.create(ReadableByteStreamController.prototype);\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);\n\n  return stream;\n}\n\nfunction InitializeReadableStream(stream: ReadableStream) {\n  stream._state = 'readable';\n  stream._reader = undefined;\n  stream._storedError = undefined;\n  stream._disturbed = false;\n}\n\nexport function IsReadableStream(x: unknown): x is ReadableStream {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\n    return false;\n  }\n\n  return x instanceof ReadableStream;\n}\n\nexport function IsReadableStreamDisturbed(stream: ReadableStream): boolean {\n  assert(IsReadableStream(stream));\n\n  return stream._disturbed;\n}\n\nexport function IsReadableStreamLocked(stream: ReadableStream): boolean {\n  assert(IsReadableStream(stream));\n\n  if (stream._reader === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\n// ReadableStream API exposed for controllers.\n\nexport function ReadableStreamCancel<R>(stream: ReadableStream<R>, reason: any): Promise<undefined> {\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    return promiseResolvedWith(undefined);\n  }\n  if (stream._state === 'errored') {\n    return promiseRejectedWith(stream._storedError);\n  }\n\n  ReadableStreamClose(stream);\n\n  const reader = stream._reader;\n  if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {\n    const readIntoRequests = reader._readIntoRequests;\n    reader._readIntoRequests = new SimpleQueue();\n    readIntoRequests.forEach(readIntoRequest => {\n      readIntoRequest._closeSteps(undefined);\n    });\n  }\n\n  const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n  return transformPromiseWith(sourceCancelPromise, noop);\n}\n\nexport function ReadableStreamClose<R>(stream: ReadableStream<R>): void {\n  assert(stream._state === 'readable');\n\n  stream._state = 'closed';\n\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return;\n  }\n\n  defaultReaderClosedPromiseResolve(reader);\n\n  if (IsReadableStreamDefaultReader<R>(reader)) {\n    const readRequests = reader._readRequests;\n    reader._readRequests = new SimpleQueue();\n    readRequests.forEach(readRequest => {\n      readRequest._closeSteps();\n    });\n  }\n}\n\nexport function ReadableStreamError<R>(stream: ReadableStream<R>, e: any): void {\n  assert(IsReadableStream(stream));\n  assert(stream._state === 'readable');\n\n  stream._state = 'errored';\n  stream._storedError = e;\n\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return;\n  }\n\n  defaultReaderClosedPromiseReject(reader, e);\n\n  if (IsReadableStreamDefaultReader<R>(reader)) {\n    ReadableStreamDefaultReaderErrorReadRequests(reader, e);\n  } else {\n    assert(IsReadableStreamBYOBReader(reader));\n    ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);\n  }\n}\n\n// Readers\n\nexport type ReadableStreamReader<R> = ReadableStreamDefaultReader<R> | ReadableStreamBYOBReader;\n\nexport {\n  ReadableStreamDefaultReader,\n  ReadableStreamBYOBReader\n};\n\n// Controllers\n\nexport {\n  ReadableStreamDefaultController,\n  ReadableStreamBYOBRequest,\n  ReadableByteStreamController\n};\n\n// Helper functions for the ReadableStream.\n\nfunction streamBrandCheckException(name: string): TypeError {\n  return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n}\n", "import type { QueuingStrategyInit } from '../queuing-strategy';\nimport { assertDictionary, assertRequiredField, convertUnrestrictedDouble } from './basic';\n\nexport function convertQueuingStrategyInit(init: QueuingStrategyInit | null | undefined,\n                                           context: string): QueuingStrategyInit {\n  assertDictionary(init, context);\n  const highWaterMark = init?.highWaterMark;\n  assertRequiredField(highWaterMark, 'highWaterMark', 'QueuingStrategyInit');\n  return {\n    highWaterMark: convertUnrestrictedDouble(highWaterMark)\n  };\n}\n", "import type { QueuingStrategy, QueuingStrategyInit } from './queuing-strategy';\nimport { setFunctionName, typeIsObject } from './helpers/miscellaneous';\nimport { assertRequiredArgument } from './validators/basic';\nimport { convertQueuingStrategyInit } from './validators/queuing-strategy-init';\n\n// The size function must not have a prototype property nor be a constructor\nconst byteLengthSizeFunction = (chunk: ArrayBufferView): number => {\n  return chunk.byteLength;\n};\nsetFunctionName(byteLengthSizeFunction, 'size');\n\n/**\n * A queuing strategy that counts the number of bytes in each chunk.\n *\n * @public\n */\nexport default class ByteLengthQueuingStrategy implements QueuingStrategy<ArrayBufferView> {\n  /** @internal */\n  readonly _byteLengthQueuingStrategyHighWaterMark: number;\n\n  constructor(options: QueuingStrategyInit) {\n    assertRequiredArgument(options, 1, 'ByteLengthQueuingStrategy');\n    options = convertQueuingStrategyInit(options, 'First parameter');\n    this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;\n  }\n\n  /**\n   * Returns the high water mark provided to the constructor.\n   */\n  get highWaterMark(): number {\n    if (!IsByteLengthQueuingStrategy(this)) {\n      throw byteLengthBrandCheckException('highWaterMark');\n    }\n    return this._byteLengthQueuingStrategyHighWaterMark;\n  }\n\n  /**\n   * Measures the size of `chunk` by returning the value of its `byteLength` property.\n   */\n  get size(): (chunk: ArrayBufferView) => number {\n    if (!IsByteLengthQueuingStrategy(this)) {\n      throw byteLengthBrandCheckException('size');\n    }\n    return byteLengthSizeFunction;\n  }\n}\n\nObject.defineProperties(ByteLengthQueuingStrategy.prototype, {\n  highWaterMark: { enumerable: true },\n  size: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ByteLengthQueuingStrategy.prototype, Symbol.toStringTag, {\n    value: 'ByteLengthQueuingStrategy',\n    configurable: true\n  });\n}\n\n// Helper functions for the ByteLengthQueuingStrategy.\n\nfunction byteLengthBrandCheckException(name: string): TypeError {\n  return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);\n}\n\nexport function IsByteLengthQueuingStrategy(x: any): x is ByteLengthQueuingStrategy {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_byteLengthQueuingStrategyHighWaterMark')) {\n    return false;\n  }\n\n  return x instanceof ByteLengthQueuingStrategy;\n}\n", "import type { QueuingStrategy, QueuingStrategyInit } from './queuing-strategy';\nimport { setFunctionName, typeIsObject } from './helpers/miscellaneous';\nimport { assertRequiredArgument } from './validators/basic';\nimport { convertQueuingStrategyInit } from './validators/queuing-strategy-init';\n\n// The size function must not have a prototype property nor be a constructor\nconst countSizeFunction = (): 1 => {\n  return 1;\n};\nsetFunctionName(countSizeFunction, 'size');\n\n/**\n * A queuing strategy that counts the number of chunks.\n *\n * @public\n */\nexport default class CountQueuingStrategy implements QueuingStrategy<any> {\n  /** @internal */\n  readonly _countQueuingStrategyHighWaterMark!: number;\n\n  constructor(options: QueuingStrategyInit) {\n    assertRequiredArgument(options, 1, 'CountQueuingStrategy');\n    options = convertQueuingStrategyInit(options, 'First parameter');\n    this._countQueuingStrategyHighWaterMark = options.highWaterMark;\n  }\n\n  /**\n   * Returns the high water mark provided to the constructor.\n   */\n  get highWaterMark(): number {\n    if (!IsCountQueuingStrategy(this)) {\n      throw countBrandCheckException('highWaterMark');\n    }\n    return this._countQueuingStrategyHighWaterMark;\n  }\n\n  /**\n   * Measures the size of `chunk` by always returning 1.\n   * This ensures that the total queue size is a count of the number of chunks in the queue.\n   */\n  get size(): (chunk: any) => 1 {\n    if (!IsCountQueuingStrategy(this)) {\n      throw countBrandCheckException('size');\n    }\n    return countSizeFunction;\n  }\n}\n\nObject.defineProperties(CountQueuingStrategy.prototype, {\n  highWaterMark: { enumerable: true },\n  size: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(CountQueuingStrategy.prototype, Symbol.toStringTag, {\n    value: 'CountQueuingStrategy',\n    configurable: true\n  });\n}\n\n// Helper functions for the CountQueuingStrategy.\n\nfunction countBrandCheckException(name: string): TypeError {\n  return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);\n}\n\nexport function IsCountQueuingStrategy(x: any): x is CountQueuingStrategy {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_countQueuingStrategyHighWaterMark')) {\n    return false;\n  }\n\n  return x instanceof CountQueuingStrategy;\n}\n", "import { assertDictionary, assertFunction } from './basic';\nimport { promiseCall, reflectCall } from '../helpers/webidl';\nimport type {\n  Transformer,\n  TransformerCancelCallback,\n  TransformerFlushCallback,\n  TransformerStartCallback,\n  TransformerTransformCallback,\n  ValidatedTransformer\n} from '../transform-stream/transformer';\nimport { TransformStreamDefaultController } from '../transform-stream';\n\nexport function convertTransformer<I, O>(original: Transformer<I, O> | null,\n                                         context: string): ValidatedTransformer<I, O> {\n  assertDictionary(original, context);\n  const cancel = original?.cancel;\n  const flush = original?.flush;\n  const readableType = original?.readableType;\n  const start = original?.start;\n  const transform = original?.transform;\n  const writableType = original?.writableType;\n  return {\n    cancel: cancel === undefined ?\n      undefined :\n      convertTransformerCancelCallback(cancel, original!, `${context} has member 'cancel' that`),\n    flush: flush === undefined ?\n      undefined :\n      convertTransformerFlushCallback(flush, original!, `${context} has member 'flush' that`),\n    readableType,\n    start: start === undefined ?\n      undefined :\n      convertTransformerStartCallback(start, original!, `${context} has member 'start' that`),\n    transform: transform === undefined ?\n      undefined :\n      convertTransformerTransformCallback(transform, original!, `${context} has member 'transform' that`),\n    writableType\n  };\n}\n\nfunction convertTransformerFlushCallback<I, O>(\n  fn: TransformerFlushCallback<O>,\n  original: Transformer<I, O>,\n  context: string\n): (controller: TransformStreamDefaultController<O>) => Promise<void> {\n  assertFunction(fn, context);\n  return (controller: TransformStreamDefaultController<O>) => promiseCall(fn, original, [controller]);\n}\n\nfunction convertTransformerStartCallback<I, O>(\n  fn: TransformerStartCallback<O>,\n  original: Transformer<I, O>,\n  context: string\n): TransformerStartCallback<O> {\n  assertFunction(fn, context);\n  return (controller: TransformStreamDefaultController<O>) => reflectCall(fn, original, [controller]);\n}\n\nfunction convertTransformerTransformCallback<I, O>(\n  fn: TransformerTransformCallback<I, O>,\n  original: Transformer<I, O>,\n  context: string\n): (chunk: I, controller: TransformStreamDefaultController<O>) => Promise<void> {\n  assertFunction(fn, context);\n  return (chunk: I, controller: TransformStreamDefaultController<O>) => promiseCall(fn, original, [chunk, controller]);\n}\n\nfunction convertTransformerCancelCallback<I, O>(\n  fn: TransformerCancelCallback,\n  original: Transformer<I, O>,\n  context: string\n): (reason: any) => Promise<void> {\n  assertFunction(fn, context);\n  return (reason: any) => promiseCall(fn, original, [reason]);\n}\n", "import assert from '../stub/assert';\nimport {\n  newPromise,\n  promiseRejectedWith,\n  promiseResolvedWith,\n  setPromiseIsHandledToTrue,\n  transformPromiseWith,\n  uponPromise\n} from './helpers/webidl';\nimport { CreateReadableStream, type DefaultReadableStream, ReadableStream } from './readable-stream';\nimport {\n  ReadableStreamDefaultControllerCanCloseOrEnqueue,\n  ReadableStreamDefaultControllerClose,\n  ReadableStreamDefaultControllerEnqueue,\n  ReadableStreamDefaultControllerError,\n  ReadableStreamDefaultControllerGetDesiredSize,\n  ReadableStreamDefaultControllerHasBackpressure\n} from './readable-stream/default-controller';\nimport type { QueuingStrategy, QueuingStrategySizeCallback } from './queuing-strategy';\nimport { CreateWritableStream, WritableStream, WritableStreamDefaultControllerErrorIfNeeded } from './writable-stream';\nimport { setFunctionName, typeIsObject } from './helpers/miscellaneous';\nimport { IsNonNegativeNumber } from './abstract-ops/miscellaneous';\nimport { convertQueuingStrategy } from './validators/queuing-strategy';\nimport { ExtractHighWaterMark, ExtractSizeAlgorithm } from './abstract-ops/queuing-strategy';\nimport type {\n  Transformer,\n  TransformerCancelCallback,\n  TransformerFlushCallback,\n  TransformerStartCallback,\n  TransformerTransformCallback,\n  ValidatedTransformer\n} from './transform-stream/transformer';\nimport { convertTransformer } from './validators/transformer';\n\n// Class TransformStream\n\n/**\n * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},\n * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.\n * In a manner specific to the transform stream in question, writes to the writable side result in new data being\n * made available for reading from the readable side.\n *\n * @public\n */\nexport class TransformStream<I = any, O = any> {\n  /** @internal */\n  _writable!: WritableStream<I>;\n  /** @internal */\n  _readable!: DefaultReadableStream<O>;\n  /** @internal */\n  _backpressure!: boolean;\n  /** @internal */\n  _backpressureChangePromise!: Promise<void>;\n  /** @internal */\n  _backpressureChangePromise_resolve!: () => void;\n  /** @internal */\n  _transformStreamController!: TransformStreamDefaultController<O>;\n\n  constructor(\n    transformer?: Transformer<I, O>,\n    writableStrategy?: QueuingStrategy<I>,\n    readableStrategy?: QueuingStrategy<O>\n  );\n  constructor(rawTransformer: Transformer<I, O> | null | undefined = {},\n              rawWritableStrategy: QueuingStrategy<I> | null | undefined = {},\n              rawReadableStrategy: QueuingStrategy<O> | null | undefined = {}) {\n    if (rawTransformer === undefined) {\n      rawTransformer = null;\n    }\n\n    const writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');\n    const readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');\n\n    const transformer = convertTransformer(rawTransformer, 'First parameter');\n    if (transformer.readableType !== undefined) {\n      throw new RangeError('Invalid readableType specified');\n    }\n    if (transformer.writableType !== undefined) {\n      throw new RangeError('Invalid writableType specified');\n    }\n\n    const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n    const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n    const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n    const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n\n    let startPromise_resolve!: (value: void | PromiseLike<void>) => void;\n    const startPromise = newPromise<void>(resolve => {\n      startPromise_resolve = resolve;\n    });\n\n    InitializeTransformStream(\n      this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm\n    );\n    SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n\n    if (transformer.start !== undefined) {\n      startPromise_resolve(transformer.start(this._transformStreamController));\n    } else {\n      startPromise_resolve(undefined);\n    }\n  }\n\n  /**\n   * The readable side of the transform stream.\n   */\n  get readable(): ReadableStream<O> {\n    if (!IsTransformStream(this)) {\n      throw streamBrandCheckException('readable');\n    }\n\n    return this._readable;\n  }\n\n  /**\n   * The writable side of the transform stream.\n   */\n  get writable(): WritableStream<I> {\n    if (!IsTransformStream(this)) {\n      throw streamBrandCheckException('writable');\n    }\n\n    return this._writable;\n  }\n}\n\nObject.defineProperties(TransformStream.prototype, {\n  readable: { enumerable: true },\n  writable: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(TransformStream.prototype, Symbol.toStringTag, {\n    value: 'TransformStream',\n    configurable: true\n  });\n}\n\nexport type {\n  Transformer,\n  TransformerCancelCallback,\n  TransformerStartCallback,\n  TransformerFlushCallback,\n  TransformerTransformCallback\n};\n\n// Transform Stream Abstract Operations\n\nexport function CreateTransformStream<I, O>(startAlgorithm: () => void | PromiseLike<void>,\n                                            transformAlgorithm: (chunk: I) => Promise<void>,\n                                            flushAlgorithm: () => Promise<void>,\n                                            cancelAlgorithm: (reason: any) => Promise<void>,\n                                            writableHighWaterMark = 1,\n                                            writableSizeAlgorithm: QueuingStrategySizeCallback<I> = () => 1,\n                                            readableHighWaterMark = 0,\n                                            readableSizeAlgorithm: QueuingStrategySizeCallback<O> = () => 1) {\n  assert(IsNonNegativeNumber(writableHighWaterMark));\n  assert(IsNonNegativeNumber(readableHighWaterMark));\n\n  const stream: TransformStream<I, O> = Object.create(TransformStream.prototype);\n\n  let startPromise_resolve!: (value: void | PromiseLike<void>) => void;\n  const startPromise = newPromise<void>(resolve => {\n    startPromise_resolve = resolve;\n  });\n\n  InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark,\n                            readableSizeAlgorithm);\n\n  const controller: TransformStreamDefaultController<O> = Object.create(TransformStreamDefaultController.prototype);\n\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm);\n\n  const startResult = startAlgorithm();\n  startPromise_resolve(startResult);\n  return stream;\n}\n\nfunction InitializeTransformStream<I, O>(stream: TransformStream<I, O>,\n                                         startPromise: Promise<void>,\n                                         writableHighWaterMark: number,\n                                         writableSizeAlgorithm: QueuingStrategySizeCallback<I>,\n                                         readableHighWaterMark: number,\n                                         readableSizeAlgorithm: QueuingStrategySizeCallback<O>) {\n  function startAlgorithm(): Promise<void> {\n    return startPromise;\n  }\n\n  function writeAlgorithm(chunk: I): Promise<void> {\n    return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n  }\n\n  function abortAlgorithm(reason: any): Promise<void> {\n    return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n  }\n\n  function closeAlgorithm(): Promise<void> {\n    return TransformStreamDefaultSinkCloseAlgorithm(stream);\n  }\n\n  stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm,\n                                          writableHighWaterMark, writableSizeAlgorithm);\n\n  function pullAlgorithm(): Promise<void> {\n    return TransformStreamDefaultSourcePullAlgorithm(stream);\n  }\n\n  function cancelAlgorithm(reason: any): Promise<void> {\n    return TransformStreamDefaultSourceCancelAlgorithm(stream, reason);\n  }\n\n  stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark,\n                                          readableSizeAlgorithm);\n\n  // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n  stream._backpressure = undefined!;\n  stream._backpressureChangePromise = undefined!;\n  stream._backpressureChangePromise_resolve = undefined!;\n  TransformStreamSetBackpressure(stream, true);\n\n  stream._transformStreamController = undefined!;\n}\n\nfunction IsTransformStream(x: unknown): x is TransformStream {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\n    return false;\n  }\n\n  return x instanceof TransformStream;\n}\n\n// This is a no-op if both sides are already errored.\nfunction TransformStreamError(stream: TransformStream, e: any) {\n  ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\n  TransformStreamErrorWritableAndUnblockWrite(stream, e);\n}\n\nfunction TransformStreamErrorWritableAndUnblockWrite(stream: TransformStream, e: any) {\n  TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n  WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n  TransformStreamUnblockWrite(stream);\n}\n\nfunction TransformStreamUnblockWrite(stream: TransformStream) {\n  if (stream._backpressure) {\n    // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n    // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n    // _backpressure is set.\n    TransformStreamSetBackpressure(stream, false);\n  }\n}\n\nfunction TransformStreamSetBackpressure(stream: TransformStream, backpressure: boolean) {\n  // Passes also when called during construction.\n  assert(stream._backpressure !== backpressure);\n\n  if (stream._backpressureChangePromise !== undefined) {\n    stream._backpressureChangePromise_resolve();\n  }\n\n  stream._backpressureChangePromise = newPromise(resolve => {\n    stream._backpressureChangePromise_resolve = resolve;\n  });\n\n  stream._backpressure = backpressure;\n}\n\n// Class TransformStreamDefaultController\n\n/**\n * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.\n *\n * @public\n */\nexport class TransformStreamDefaultController<O> {\n  /** @internal */\n  _controlledTransformStream: TransformStream<any, O>;\n  /** @internal */\n  _finishPromise: Promise<undefined> | undefined;\n  /** @internal */\n  _finishPromise_resolve?: (value?: undefined) => void;\n  /** @internal */\n  _finishPromise_reject?: (reason: any) => void;\n  /** @internal */\n  _transformAlgorithm: (chunk: any) => Promise<void>;\n  /** @internal */\n  _flushAlgorithm: () => Promise<void>;\n  /** @internal */\n  _cancelAlgorithm: (reason: any) => Promise<void>;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * Returns the desired size to fill the readable sides internal queue. It can be negative, if the queue is over-full.\n   */\n  get desiredSize(): number | null {\n    if (!IsTransformStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('desiredSize');\n    }\n\n    const readableController = this._controlledTransformStream._readable._readableStreamController;\n    return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n  }\n\n  /**\n   * Enqueues the given chunk `chunk` in the readable side of the controlled transform stream.\n   */\n  enqueue(chunk: O): void;\n  enqueue(chunk: O = undefined!): void {\n    if (!IsTransformStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('enqueue');\n    }\n\n    TransformStreamDefaultControllerEnqueue(this, chunk);\n  }\n\n  /**\n   * Errors both the readable side and the writable side of the controlled transform stream, making all future\n   * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\n   */\n  error(reason: any = undefined): void {\n    if (!IsTransformStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('error');\n    }\n\n    TransformStreamDefaultControllerError(this, reason);\n  }\n\n  /**\n   * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\n   * transformer only needs to consume a portion of the chunks written to the writable side.\n   */\n  terminate(): void {\n    if (!IsTransformStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('terminate');\n    }\n\n    TransformStreamDefaultControllerTerminate(this);\n  }\n}\n\nObject.defineProperties(TransformStreamDefaultController.prototype, {\n  enqueue: { enumerable: true },\n  error: { enumerable: true },\n  terminate: { enumerable: true },\n  desiredSize: { enumerable: true }\n});\nsetFunctionName(TransformStreamDefaultController.prototype.enqueue, 'enqueue');\nsetFunctionName(TransformStreamDefaultController.prototype.error, 'error');\nsetFunctionName(TransformStreamDefaultController.prototype.terminate, 'terminate');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(TransformStreamDefaultController.prototype, Symbol.toStringTag, {\n    value: 'TransformStreamDefaultController',\n    configurable: true\n  });\n}\n\n// Transform Stream Default Controller Abstract Operations\n\nfunction IsTransformStreamDefaultController<O = any>(x: any): x is TransformStreamDefaultController<O> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\n    return false;\n  }\n\n  return x instanceof TransformStreamDefaultController;\n}\n\nfunction SetUpTransformStreamDefaultController<I, O>(stream: TransformStream<I, O>,\n                                                     controller: TransformStreamDefaultController<O>,\n                                                     transformAlgorithm: (chunk: I) => Promise<void>,\n                                                     flushAlgorithm: () => Promise<void>,\n                                                     cancelAlgorithm: (reason: any) => Promise<void>) {\n  assert(IsTransformStream(stream));\n  assert(stream._transformStreamController === undefined);\n\n  controller._controlledTransformStream = stream;\n  stream._transformStreamController = controller;\n\n  controller._transformAlgorithm = transformAlgorithm;\n  controller._flushAlgorithm = flushAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n\n  controller._finishPromise = undefined;\n  controller._finishPromise_resolve = undefined;\n  controller._finishPromise_reject = undefined;\n}\n\nfunction SetUpTransformStreamDefaultControllerFromTransformer<I, O>(stream: TransformStream<I, O>,\n                                                                    transformer: ValidatedTransformer<I, O>) {\n  const controller: TransformStreamDefaultController<O> = Object.create(TransformStreamDefaultController.prototype);\n\n  let transformAlgorithm: (chunk: I) => Promise<void>;\n  let flushAlgorithm: () => Promise<void>;\n  let cancelAlgorithm: (reason: any) => Promise<void>;\n\n  if (transformer.transform !== undefined) {\n    transformAlgorithm = chunk => transformer.transform!(chunk, controller);\n  } else {\n    transformAlgorithm = chunk => {\n      try {\n        TransformStreamDefaultControllerEnqueue(controller, chunk as unknown as O);\n        return promiseResolvedWith(undefined);\n      } catch (transformResultE) {\n        return promiseRejectedWith(transformResultE);\n      }\n    };\n  }\n\n  if (transformer.flush !== undefined) {\n    flushAlgorithm = () => transformer.flush!(controller);\n  } else {\n    flushAlgorithm = () => promiseResolvedWith(undefined);\n  }\n\n  if (transformer.cancel !== undefined) {\n    cancelAlgorithm = reason => transformer.cancel!(reason);\n  } else {\n    cancelAlgorithm = () => promiseResolvedWith(undefined);\n  }\n\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm);\n}\n\nfunction TransformStreamDefaultControllerClearAlgorithms(controller: TransformStreamDefaultController<any>) {\n  controller._transformAlgorithm = undefined!;\n  controller._flushAlgorithm = undefined!;\n  controller._cancelAlgorithm = undefined!;\n}\n\nfunction TransformStreamDefaultControllerEnqueue<O>(controller: TransformStreamDefaultController<O>, chunk: O) {\n  const stream = controller._controlledTransformStream;\n  const readableController = stream._readable._readableStreamController;\n  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n    throw new TypeError('Readable side is not in a state that permits enqueue');\n  }\n\n  // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n  // accept TransformStreamDefaultControllerEnqueue() calls.\n\n  try {\n    ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n  } catch (e) {\n    // This happens when readableStrategy.size() throws.\n    TransformStreamErrorWritableAndUnblockWrite(stream, e);\n\n    throw stream._readable._storedError;\n  }\n\n  const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n  if (backpressure !== stream._backpressure) {\n    assert(backpressure);\n    TransformStreamSetBackpressure(stream, true);\n  }\n}\n\nfunction TransformStreamDefaultControllerError(controller: TransformStreamDefaultController<any>, e: any) {\n  TransformStreamError(controller._controlledTransformStream, e);\n}\n\nfunction TransformStreamDefaultControllerPerformTransform<I, O>(controller: TransformStreamDefaultController<O>,\n                                                                chunk: I) {\n  const transformPromise = controller._transformAlgorithm(chunk);\n  return transformPromiseWith(transformPromise, undefined, r => {\n    TransformStreamError(controller._controlledTransformStream, r);\n    throw r;\n  });\n}\n\nfunction TransformStreamDefaultControllerTerminate<O>(controller: TransformStreamDefaultController<O>) {\n  const stream = controller._controlledTransformStream;\n  const readableController = stream._readable._readableStreamController;\n\n  ReadableStreamDefaultControllerClose(readableController);\n\n  const error = new TypeError('TransformStream terminated');\n  TransformStreamErrorWritableAndUnblockWrite(stream, error);\n}\n\n// TransformStreamDefaultSink Algorithms\n\nfunction TransformStreamDefaultSinkWriteAlgorithm<I, O>(stream: TransformStream<I, O>, chunk: I): Promise<void> {\n  assert(stream._writable._state === 'writable');\n\n  const controller = stream._transformStreamController;\n\n  if (stream._backpressure) {\n    const backpressureChangePromise = stream._backpressureChangePromise;\n    assert(backpressureChangePromise !== undefined);\n    return transformPromiseWith(backpressureChangePromise, () => {\n      const writable = stream._writable;\n      const state = writable._state;\n      if (state === 'erroring') {\n        throw writable._storedError;\n      }\n      assert(state === 'writable');\n      return TransformStreamDefaultControllerPerformTransform<I, O>(controller, chunk);\n    });\n  }\n\n  return TransformStreamDefaultControllerPerformTransform<I, O>(controller, chunk);\n}\n\nfunction TransformStreamDefaultSinkAbortAlgorithm<I, O>(stream: TransformStream<I, O>, reason: any): Promise<void> {\n  const controller = stream._transformStreamController;\n  if (controller._finishPromise !== undefined) {\n    return controller._finishPromise;\n  }\n\n  // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n  const readable = stream._readable;\n\n  // Assign the _finishPromise now so that if _cancelAlgorithm calls readable.cancel() internally,\n  // we don't run the _cancelAlgorithm again.\n  controller._finishPromise = newPromise((resolve, reject) => {\n    controller._finishPromise_resolve = resolve;\n    controller._finishPromise_reject = reject;\n  });\n\n  const cancelPromise = controller._cancelAlgorithm(reason);\n  TransformStreamDefaultControllerClearAlgorithms(controller);\n\n  uponPromise(cancelPromise, () => {\n    if (readable._state === 'errored') {\n      defaultControllerFinishPromiseReject(controller, readable._storedError);\n    } else {\n      ReadableStreamDefaultControllerError(readable._readableStreamController, reason);\n      defaultControllerFinishPromiseResolve(controller);\n    }\n    return null;\n  }, r => {\n    ReadableStreamDefaultControllerError(readable._readableStreamController, r);\n    defaultControllerFinishPromiseReject(controller, r);\n    return null;\n  });\n\n  return controller._finishPromise;\n}\n\nfunction TransformStreamDefaultSinkCloseAlgorithm<I, O>(stream: TransformStream<I, O>): Promise<void> {\n  const controller = stream._transformStreamController;\n  if (controller._finishPromise !== undefined) {\n    return controller._finishPromise;\n  }\n\n  // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n  const readable = stream._readable;\n\n  // Assign the _finishPromise now so that if _flushAlgorithm calls readable.cancel() internally,\n  // we don't also run the _cancelAlgorithm.\n  controller._finishPromise = newPromise((resolve, reject) => {\n    controller._finishPromise_resolve = resolve;\n    controller._finishPromise_reject = reject;\n  });\n\n  const flushPromise = controller._flushAlgorithm();\n  TransformStreamDefaultControllerClearAlgorithms(controller);\n\n  uponPromise(flushPromise, () => {\n    if (readable._state === 'errored') {\n      defaultControllerFinishPromiseReject(controller, readable._storedError);\n    } else {\n      ReadableStreamDefaultControllerClose(readable._readableStreamController);\n      defaultControllerFinishPromiseResolve(controller);\n    }\n    return null;\n  }, r => {\n    ReadableStreamDefaultControllerError(readable._readableStreamController, r);\n    defaultControllerFinishPromiseReject(controller, r);\n    return null;\n  });\n\n  return controller._finishPromise;\n}\n\n// TransformStreamDefaultSource Algorithms\n\nfunction TransformStreamDefaultSourcePullAlgorithm(stream: TransformStream): Promise<void> {\n  // Invariant. Enforced by the promises returned by start() and pull().\n  assert(stream._backpressure);\n\n  assert(stream._backpressureChangePromise !== undefined);\n\n  TransformStreamSetBackpressure(stream, false);\n\n  // Prevent the next pull() call until there is backpressure.\n  return stream._backpressureChangePromise;\n}\n\nfunction TransformStreamDefaultSourceCancelAlgorithm<I, O>(stream: TransformStream<I, O>, reason: any): Promise<void> {\n  const controller = stream._transformStreamController;\n  if (controller._finishPromise !== undefined) {\n    return controller._finishPromise;\n  }\n\n  // stream._writable cannot change after construction, so caching it across a call to user code is safe.\n  const writable = stream._writable;\n\n  // Assign the _finishPromise now so that if _flushAlgorithm calls writable.abort() or\n  // writable.cancel() internally, we don't run the _cancelAlgorithm again, or also run the\n  // _flushAlgorithm.\n  controller._finishPromise = newPromise((resolve, reject) => {\n    controller._finishPromise_resolve = resolve;\n    controller._finishPromise_reject = reject;\n  });\n\n  const cancelPromise = controller._cancelAlgorithm(reason);\n  TransformStreamDefaultControllerClearAlgorithms(controller);\n\n  uponPromise(cancelPromise, () => {\n    if (writable._state === 'errored') {\n      defaultControllerFinishPromiseReject(controller, writable._storedError);\n    } else {\n      WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, reason);\n      TransformStreamUnblockWrite(stream);\n      defaultControllerFinishPromiseResolve(controller);\n    }\n    return null;\n  }, r => {\n    WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, r);\n    TransformStreamUnblockWrite(stream);\n    defaultControllerFinishPromiseReject(controller, r);\n    return null;\n  });\n\n  return controller._finishPromise;\n}\n\n// Helper functions for the TransformStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n}\n\nexport function defaultControllerFinishPromiseResolve(controller: TransformStreamDefaultController<any>) {\n  if (controller._finishPromise_resolve === undefined) {\n    return;\n  }\n\n  controller._finishPromise_resolve();\n  controller._finishPromise_resolve = undefined;\n  controller._finishPromise_reject = undefined;\n}\n\nexport function defaultControllerFinishPromiseReject(controller: TransformStreamDefaultController<any>, reason: any) {\n  if (controller._finishPromise_reject === undefined) {\n    return;\n  }\n\n  setPromiseIsHandledToTrue(controller._finishPromise!);\n  controller._finishPromise_reject(reason);\n  controller._finishPromise_resolve = undefined;\n  controller._finishPromise_reject = undefined;\n}\n\n// Helper functions for the TransformStream.\n\nfunction streamBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `TransformStream.prototype.${name} can only be used on a TransformStream`);\n}\n", "/* c8 ignore start */\n// 64 KiB (same size chrome slice theirs blob into Uint8array's)\nconst POOL_SIZE = 65536\n\nif (!globalThis.ReadableStream) {\n  // `node:stream/web` got introduced in v16.5.0 as experimental\n  // and it's preferred over the polyfilled version. So we also\n  // suppress the warning that gets emitted by NodeJS for using it.\n  try {\n    const process = require('node:process')\n    const { emitWarning } = process\n    try {\n      process.emitWarning = () => {}\n      Object.assign(globalThis, require('node:stream/web'))\n      process.emitWarning = emitWarning\n    } catch (error) {\n      process.emitWarning = emitWarning\n      throw error\n    }\n  } catch (error) {\n    // fallback to polyfill implementation\n    Object.assign(globalThis, require('web-streams-polyfill/dist/ponyfill.es2018.js'))\n  }\n}\n\ntry {\n  // Don't use node: prefix for this, require+node: is not supported until node v14.14\n  // Only `import()` can use prefix in 12.20 and later\n  const { Blob } = require('buffer')\n  if (Blob && !Blob.prototype.stream) {\n    Blob.prototype.stream = function name (params) {\n      let position = 0\n      const blob = this\n\n      return new ReadableStream({\n        type: 'bytes',\n        async pull (ctrl) {\n          const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE))\n          const buffer = await chunk.arrayBuffer()\n          position += buffer.byteLength\n          ctrl.enqueue(new Uint8Array(buffer))\n\n          if (position === blob.size) {\n            ctrl.close()\n          }\n        }\n      })\n    }\n  }\n} catch (error) {}\n/* c8 ignore end */\n", "/*! node-domexception. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */\n\nif (!globalThis.DOMException) {\n  try {\n    const { MessageChannel } = require('worker_threads'),\n    port = new MessageChannel().port1,\n    ab = new ArrayBuffer()\n    port.postMessage(ab, [ab, ab])\n  } catch (err) {\n    err.constructor.name === 'DOMException' && (\n      globalThis.DOMException = err.constructor\n    )\n  }\n}\n\nmodule.exports = globalThis.DOMException\n", "import Blob from './index.js'\n\nconst _File = class File extends Blob {\n  #lastModified = 0\n  #name = ''\n\n  /**\n   * @param {*[]} fileBits\n   * @param {string} fileName\n   * @param {{lastModified?: number, type?: string}} options\n   */// @ts-ignore\n  constructor (fileBits, fileName, options = {}) {\n    if (arguments.length < 2) {\n      throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`)\n    }\n    super(fileBits, options)\n\n    if (options === null) options = {}\n\n    // Simulate WebIDL type casting for NaN value in lastModified option.\n    const lastModified = options.lastModified === undefined ? Date.now() : Number(options.lastModified)\n    if (!Number.isNaN(lastModified)) {\n      this.#lastModified = lastModified\n    }\n\n    this.#name = String(fileName)\n  }\n\n  get name () {\n    return this.#name\n  }\n\n  get lastModified () {\n    return this.#lastModified\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'File'\n  }\n\n  static [Symbol.hasInstance] (object) {\n    return !!object && object instanceof Blob &&\n      /^(File)$/.test(object[Symbol.toStringTag])\n  }\n}\n\n/** @type {typeof globalThis.File} */// @ts-ignore\nexport const File = _File\nexport default File\n", "/*! fetch-blob. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */\n\n// TODO (jimmywarting): in the feature use conditional loading with top level await (requires 14.x)\n// Node has recently added whatwg stream into core\n\nimport './streams.cjs'\n\n// 64 KiB (same size chrome slice theirs blob into Uint8array's)\nconst POOL_SIZE = 65536\n\n/** @param {(Blob | Uint8Array)[]} parts */\nasync function * toIterator (parts, clone = true) {\n  for (const part of parts) {\n    if ('stream' in part) {\n      yield * (/** @type {AsyncIterableIterator<Uint8Array>} */ (part.stream()))\n    } else if (ArrayBuffer.isView(part)) {\n      if (clone) {\n        let position = part.byteOffset\n        const end = part.byteOffset + part.byteLength\n        while (position !== end) {\n          const size = Math.min(end - position, POOL_SIZE)\n          const chunk = part.buffer.slice(position, position + size)\n          position += chunk.byteLength\n          yield new Uint8Array(chunk)\n        }\n      } else {\n        yield part\n      }\n    /* c8 ignore next 10 */\n    } else {\n      // For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)\n      let position = 0, b = (/** @type {Blob} */ (part))\n      while (position !== b.size) {\n        const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE))\n        const buffer = await chunk.arrayBuffer()\n        position += buffer.byteLength\n        yield new Uint8Array(buffer)\n      }\n    }\n  }\n}\n\nconst _Blob = class Blob {\n  /** @type {Array.<(Blob|Uint8Array)>} */\n  #parts = []\n  #type = ''\n  #size = 0\n  #endings = 'transparent'\n\n  /**\n   * The Blob() constructor returns a new Blob object. The content\n   * of the blob consists of the concatenation of the values given\n   * in the parameter array.\n   *\n   * @param {*} blobParts\n   * @param {{ type?: string, endings?: string }} [options]\n   */\n  constructor (blobParts = [], options = {}) {\n    if (typeof blobParts !== 'object' || blobParts === null) {\n      throw new TypeError('Failed to construct \\'Blob\\': The provided value cannot be converted to a sequence.')\n    }\n\n    if (typeof blobParts[Symbol.iterator] !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': The object must have a callable @@iterator property.')\n    }\n\n    if (typeof options !== 'object' && typeof options !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': parameter 2 cannot convert to dictionary.')\n    }\n\n    if (options === null) options = {}\n\n    const encoder = new TextEncoder()\n    for (const element of blobParts) {\n      let part\n      if (ArrayBuffer.isView(element)) {\n        part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength))\n      } else if (element instanceof ArrayBuffer) {\n        part = new Uint8Array(element.slice(0))\n      } else if (element instanceof Blob) {\n        part = element\n      } else {\n        part = encoder.encode(`${element}`)\n      }\n\n      this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size\n      this.#parts.push(part)\n    }\n\n    this.#endings = `${options.endings === undefined ? 'transparent' : options.endings}`\n    const type = options.type === undefined ? '' : String(options.type)\n    this.#type = /^[\\x20-\\x7E]*$/.test(type) ? type : ''\n  }\n\n  /**\n   * The Blob interface's size property returns the\n   * size of the Blob in bytes.\n   */\n  get size () {\n    return this.#size\n  }\n\n  /**\n   * The type property of a Blob object returns the MIME type of the file.\n   */\n  get type () {\n    return this.#type\n  }\n\n  /**\n   * The text() method in the Blob interface returns a Promise\n   * that resolves with a string containing the contents of\n   * the blob, interpreted as UTF-8.\n   *\n   * @return {Promise<string>}\n   */\n  async text () {\n    // More optimized than using this.arrayBuffer()\n    // that requires twice as much ram\n    const decoder = new TextDecoder()\n    let str = ''\n    for await (const part of toIterator(this.#parts, false)) {\n      str += decoder.decode(part, { stream: true })\n    }\n    // Remaining\n    str += decoder.decode()\n    return str\n  }\n\n  /**\n   * The arrayBuffer() method in the Blob interface returns a\n   * Promise that resolves with the contents of the blob as\n   * binary data contained in an ArrayBuffer.\n   *\n   * @return {Promise<ArrayBuffer>}\n   */\n  async arrayBuffer () {\n    // Easier way... Just a unnecessary overhead\n    // const view = new Uint8Array(this.size);\n    // await this.stream().getReader({mode: 'byob'}).read(view);\n    // return view.buffer;\n\n    const data = new Uint8Array(this.size)\n    let offset = 0\n    for await (const chunk of toIterator(this.#parts, false)) {\n      data.set(chunk, offset)\n      offset += chunk.length\n    }\n\n    return data.buffer\n  }\n\n  stream () {\n    const it = toIterator(this.#parts, true)\n\n    return new globalThis.ReadableStream({\n      // @ts-ignore\n      type: 'bytes',\n      async pull (ctrl) {\n        const chunk = await it.next()\n        chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value)\n      },\n\n      async cancel () {\n        await it.return()\n      }\n    })\n  }\n\n  /**\n   * The Blob interface's slice() method creates and returns a\n   * new Blob object which contains data from a subset of the\n   * blob on which it's called.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @param {string} [type]\n   */\n  slice (start = 0, end = this.size, type = '') {\n    const { size } = this\n\n    let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size)\n    let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size)\n\n    const span = Math.max(relativeEnd - relativeStart, 0)\n    const parts = this.#parts\n    const blobParts = []\n    let added = 0\n\n    for (const part of parts) {\n      // don't add the overflow to new blobParts\n      if (added >= span) {\n        break\n      }\n\n      const size = ArrayBuffer.isView(part) ? part.byteLength : part.size\n      if (relativeStart && size <= relativeStart) {\n        // Skip the beginning and change the relative\n        // start & end position as we skip the unwanted parts\n        relativeStart -= size\n        relativeEnd -= size\n      } else {\n        let chunk\n        if (ArrayBuffer.isView(part)) {\n          chunk = part.subarray(relativeStart, Math.min(size, relativeEnd))\n          added += chunk.byteLength\n        } else {\n          chunk = part.slice(relativeStart, Math.min(size, relativeEnd))\n          added += chunk.size\n        }\n        relativeEnd -= size\n        blobParts.push(chunk)\n        relativeStart = 0 // All next sequential parts should start at 0\n      }\n    }\n\n    const blob = new Blob([], { type: String(type).toLowerCase() })\n    blob.#size = span\n    blob.#parts = blobParts\n\n    return blob\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Blob'\n  }\n\n  static [Symbol.hasInstance] (object) {\n    return (\n      object &&\n      typeof object === 'object' &&\n      typeof object.constructor === 'function' &&\n      (\n        typeof object.stream === 'function' ||\n        typeof object.arrayBuffer === 'function'\n      ) &&\n      /^(Blob|File)$/.test(object[Symbol.toStringTag])\n    )\n  }\n}\n\nObject.defineProperties(_Blob.prototype, {\n  size: { enumerable: true },\n  type: { enumerable: true },\n  slice: { enumerable: true }\n})\n\n/** @type {typeof globalThis.Blob} */\nexport const Blob = _Blob\nexport default Blob\n", "/*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */\n\nimport C from 'fetch-blob'\nimport F from 'fetch-blob/file.js'\n\nvar {toStringTag:t,iterator:i,hasInstance:h}=Symbol,\nr=Math.random,\nm='append,set,get,getAll,delete,keys,values,entries,forEach,constructor'.split(','),\nf=(a,b,c)=>(a+='',/^(Blob|File)$/.test(b && b[t])?[(c=c!==void 0?c+'':b[t]=='File'?b.name:'blob',a),b.name!==c||b[t]=='blob'?new F([b],c,b):b]:[a,b+'']),\ne=(c,f)=>(f?c:c.replace(/\\r?\\n|\\r/g,'\\r\\n')).replace(/\\n/g,'%0A').replace(/\\r/g,'%0D').replace(/\"/g,'%22'),\nx=(n, a, e)=>{if(a.length<e){throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e} arguments required, but only ${a.length} present.`)}}\n\nexport const File = F\n\n/** @type {typeof globalThis.FormData} */\nexport const FormData = class FormData {\n#d=[];\nconstructor(...a){if(a.length)throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`)}\nget [t]() {return 'FormData'}\n[i](){return this.entries()}\nstatic [h](o) {return o&&typeof o==='object'&&o[t]==='FormData'&&!m.some(m=>typeof o[m]!='function')}\nappend(...a){x('append',arguments,2);this.#d.push(f(...a))}\ndelete(a){x('delete',arguments,1);a+='';this.#d=this.#d.filter(([b])=>b!==a)}\nget(a){x('get',arguments,1);a+='';for(var b=this.#d,l=b.length,c=0;c<l;c++)if(b[c][0]===a)return b[c][1];return null}\ngetAll(a,b){x('getAll',arguments,1);b=[];a+='';this.#d.forEach(c=>c[0]===a&&b.push(c[1]));return b}\nhas(a){x('has',arguments,1);a+='';return this.#d.some(b=>b[0]===a)}\nforEach(a,b){x('forEach',arguments,1);for(var [c,d]of this)a.call(b,d,c,this)}\nset(...a){x('set',arguments,2);var b=[],c=!0;a=f(...a);this.#d.forEach(d=>{d[0]===a[0]?c&&(c=!b.push(a)):b.push(d)});c&&b.push(a);this.#d=b}\n*entries(){yield*this.#d}\n*keys(){for(var[a]of this)yield a}\n*values(){for(var[,a]of this)yield a}}\n\n/** @param {FormData} F */\nexport function formDataToBlob (F,B=C){\nvar b=`${r()}${r()}`.replace(/\\./g, '').slice(-28).padStart(32, '-'),c=[],p=`--${b}\\r\\nContent-Disposition: form-data; name=\"`\nF.forEach((v,n)=>typeof v=='string'\n?c.push(p+e(n)+`\"\\r\\n\\r\\n${v.replace(/\\r(?!\\n)|(?<!\\r)\\n/g, '\\r\\n')}\\r\\n`)\n:c.push(p+e(n)+`\"; filename=\"${e(v.name, 1)}\"\\r\\nContent-Type: ${v.type||\"application/octet-stream\"}\\r\\n\\r\\n`, v, '\\r\\n'))\nc.push(`--${b}--`)\nreturn new B(c,{type:\"multipart/form-data; boundary=\"+b})}\n", "import { statSync, createReadStream, promises as fs } from 'node:fs'\nimport { basename } from 'node:path'\nimport DOMException from 'node-domexception'\n\nimport File from './file.js'\nimport Blob from './index.js'\n\nconst { stat } = fs\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\nconst blobFromSync = (path, type) => fromBlob(statSync(path), path, type)\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<Blob>}\n */\nconst blobFrom = (path, type) => stat(path).then(stat => fromBlob(stat, path, type))\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<File>}\n */\nconst fileFrom = (path, type) => stat(path).then(stat => fromFile(stat, path, type))\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\nconst fileFromSync = (path, type) => fromFile(statSync(path), path, type)\n\n// @ts-ignore\nconst fromBlob = (stat, path, type = '') => new Blob([new BlobDataItem({\n  path,\n  size: stat.size,\n  lastModified: stat.mtimeMs,\n  start: 0\n})], { type })\n\n// @ts-ignore\nconst fromFile = (stat, path, type = '') => new File([new BlobDataItem({\n  path,\n  size: stat.size,\n  lastModified: stat.mtimeMs,\n  start: 0\n})], basename(path), { type, lastModified: stat.mtimeMs })\n\n/**\n * This is a blob backed up by a file on the disk\n * with minium requirement. Its wrapped around a Blob as a blobPart\n * so you have no direct access to this.\n *\n * @private\n */\nclass BlobDataItem {\n  #path\n  #start\n\n  constructor (options) {\n    this.#path = options.path\n    this.#start = options.start\n    this.size = options.size\n    this.lastModified = options.lastModified\n  }\n\n  /**\n   * Slicing arguments is first validated and formatted\n   * to not be out of range by Blob.prototype.slice\n   */\n  slice (start, end) {\n    return new BlobDataItem({\n      path: this.#path,\n      lastModified: this.lastModified,\n      size: end - start,\n      start: this.#start + start\n    })\n  }\n\n  async * stream () {\n    const { mtimeMs } = await stat(this.#path)\n    if (mtimeMs > this.lastModified) {\n      throw new DOMException('The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.', 'NotReadableError')\n    }\n    yield * createReadStream(this.#path, {\n      start: this.#start,\n      end: this.#start + this.size - 1\n    })\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Blob'\n  }\n}\n\nexport default blobFromSync\nexport { File, Blob, blobFrom, blobFromSync, fileFrom, fileFromSync }\n"],
  "mappings": "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",
  "names": ["x", "_a", "i", "e", "queueMicrotask", "r", "streamBrandCheckException", "defaultControllerBrandCheckException", "DOMException", "ReadableStream", "POOL_SIZE", "Blob", "size", "Blob", "File", "f", "e", "FormData", "m"]
}
