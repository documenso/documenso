diff --git a/node_modules/@napi-rs/canvas/index.js b/node_modules/@napi-rs/canvas/index.js
index 7545c4e..94ecbc2 100644
--- a/node_modules/@napi-rs/canvas/index.js
+++ b/node_modules/@napi-rs/canvas/index.js
@@ -6,7 +6,7 @@ const {
   CanvasRenderingContext2D,
   CanvasElement,
   SVGCanvas,
-  Path: Path2D,
+  Path: NativePath2D,
   ImageData,
   Image,
   FontKey,
@@ -23,6 +23,38 @@ const { DOMPoint, DOMMatrix, DOMRect } = require('./geometry')
 
 const loadImage = require('./load-image')
 
+// Wrapper for Path2D to handle webpack bundling issues
+// When a Path2D-like object from a bundled environment is passed to the constructor,
+// we need to ensure it's properly recognized by the native binding.
+// See: https://github.com/Brooooooklyn/canvas/issues/1126
+class Path2D extends NativePath2D {
+  constructor(path) {
+    // If path is a Path2D-like object but not recognized as NativePath2D,
+    // convert it to SVG string first, then create a new path from that
+    if (path && typeof path === 'object' && !(path instanceof NativePath2D)) {
+      // Check if it looks like a Path2D by checking for toSVGString method
+      if (typeof path.toSVGString === 'function') {
+        // Convert to SVG string and create from that
+        super(path.toSVGString())
+        return
+      }
+    }
+    super(path)
+  }
+}
+
+// Export Path2D to globalThis so that libraries like pdfjs-dist that use
+// globalThis.Path2D will get the correct class. This is critical for
+// webpack bundling scenarios where module identity can be lost.
+// See: https://github.com/Brooooooklyn/canvas/issues/1126
+if (typeof globalThis !== 'undefined') {
+  // Only set if not already set, or if it's not our NativePath2D
+  // This ensures we don't overwrite a working globalThis.Path2D
+  if (!globalThis.Path2D || !(new globalThis.Path2D() instanceof NativePath2D)) {
+    globalThis.Path2D = Path2D
+  }
+}
+
 const SvgExportFlag = {
   ConvertTextToPaths: 0x01,
   NoPrettyXML: 0x02,
@@ -122,6 +154,173 @@ CanvasRenderingContext2D.prototype.drawImage = function drawImage(image, ...args
   return _drawImage.apply(this, [image, ...args])
 }
 
+// Workaround for webpack bundling issue with Path2D
+// When webpack bundles the code, the instanceof check for Path2D can fail
+// because the prototype chain gets modified. This affects fill, stroke, clip,
+// isPointInPath, and isPointInStroke methods.
+// See: https://github.com/Brooooooklyn/canvas/issues/1126
+
+// Debug flag - set NAPI_CANVAS_DEBUG=1 to enable debug logging
+const DEBUG_PATH2D = process.env.NAPI_CANVAS_DEBUG === '1'
+
+/**
+ * Convert a Path2D-like object to a proper NativePath2D instance.
+ *
+ * N-API class instances have internal native data that cannot be fixed by
+ * Object.setPrototypeOf(). We must create a completely new NativePath2D
+ * from the SVG string representation to get a valid native object.
+ *
+ * See: https://github.com/Brooooooklyn/canvas/issues/1126
+ */
+function ensurePath2D(obj) {
+  // Already a valid native Path2D - return as-is
+  if (obj instanceof NativePath2D) {
+    if (DEBUG_PATH2D) console.log('[napi-canvas] Path2D is already NativePath2D')
+    return obj
+  }
+
+  if (DEBUG_PATH2D) {
+    console.log('[napi-canvas] ensurePath2D called with:', {
+      type: typeof obj,
+      constructor: obj?.constructor?.name,
+      hasToSVGString: typeof obj?.toSVGString === 'function',
+      hasAddPath: typeof obj?.addPath === 'function',
+      prototype: Object.getPrototypeOf(obj)?.constructor?.name,
+    })
+  }
+
+  // Try to convert using toSVGString if available (works for @napi-rs/canvas Path2D from different module instances)
+  if (obj && typeof obj === 'object' && typeof obj.toSVGString === 'function') {
+    try {
+      const svgString = obj.toSVGString()
+      if (DEBUG_PATH2D) console.log('[napi-canvas] toSVGString result:', svgString?.substring?.(0, 100))
+
+      // Handle empty paths - create an empty NativePath2D
+      if (svgString === '' || svgString === 'M0 0') {
+        return new NativePath2D()
+      }
+
+      if (typeof svgString === 'string' && svgString.length > 0) {
+        const newPath = new NativePath2D(svgString)
+        if (DEBUG_PATH2D) console.log('[napi-canvas] Successfully created NativePath2D from SVG string')
+        return newPath
+      }
+    } catch (e) {
+      if (DEBUG_PATH2D) console.log('[napi-canvas] toSVGString conversion failed:', e.message)
+    }
+  }
+
+  // Check constructor name - @napi-rs/canvas internally names the class "Path"
+  const constructorName = obj?.constructor?.name
+  if (constructorName === 'Path' || constructorName === 'Path2D') {
+    if (DEBUG_PATH2D) console.log('[napi-canvas] Detected Path/Path2D constructor, attempting prototype fix')
+
+    // Try prototype chain fix as a fallback
+    // This might work in some edge cases where the object has native data but wrong prototype
+    try {
+      Object.setPrototypeOf(obj, NativePath2D.prototype)
+      return obj
+    } catch (e) {
+      if (DEBUG_PATH2D) console.log('[napi-canvas] Prototype fix failed:', e.message)
+    }
+  }
+
+  // Last resort for objects that look like Path2D but can't be converted
+  // Try creating an empty path if the object exists but has no conversion method
+  if (obj && typeof obj === 'object') {
+    // Check if it has Path2D-like methods (addPath, moveTo, lineTo, etc.)
+    const hasPathMethods = typeof obj.addPath === 'function' &&
+                          typeof obj.moveTo === 'function' &&
+                          typeof obj.lineTo === 'function'
+
+    if (hasPathMethods) {
+      if (DEBUG_PATH2D) console.log('[napi-canvas] Object has Path2D methods but no toSVGString - cannot convert')
+      // We can't convert this, but let's give a clear error message
+      console.warn(
+        '[@napi-rs/canvas] Received a Path2D-like object that cannot be converted. ' +
+        'This usually happens with webpack bundling. ' +
+        'Ensure you are using the Path2D exported from @napi-rs/canvas. ' +
+        'Object constructor:', constructorName
+      )
+    }
+  }
+
+  return obj
+}
+
+// Store original methods
+const _fill = CanvasRenderingContext2D.prototype.fill
+const _stroke = CanvasRenderingContext2D.prototype.stroke
+const _clip = CanvasRenderingContext2D.prototype.clip
+const _isPointInPath = CanvasRenderingContext2D.prototype.isPointInPath
+const _isPointInStroke = CanvasRenderingContext2D.prototype.isPointInStroke
+
+// Override fill to handle Path2D-like objects from bundled environments
+CanvasRenderingContext2D.prototype.fill = function fill(pathOrRule, rule) {
+  if (pathOrRule && typeof pathOrRule === 'object' && typeof pathOrRule !== 'string') {
+    pathOrRule = ensurePath2D(pathOrRule)
+  }
+  if (arguments.length === 0) {
+    return _fill.call(this)
+  } else if (arguments.length === 1) {
+    return _fill.call(this, pathOrRule)
+  } else {
+    return _fill.call(this, pathOrRule, rule)
+  }
+}
+
+// Override stroke to handle Path2D-like objects from bundled environments
+CanvasRenderingContext2D.prototype.stroke = function stroke(path) {
+  if (path && typeof path === 'object') {
+    path = ensurePath2D(path)
+  }
+  if (arguments.length === 0) {
+    return _stroke.call(this)
+  } else {
+    return _stroke.call(this, path)
+  }
+}
+
+// Override clip to handle Path2D-like objects from bundled environments
+CanvasRenderingContext2D.prototype.clip = function clip(pathOrRule, rule) {
+  if (pathOrRule && typeof pathOrRule === 'object' && typeof pathOrRule !== 'string') {
+    pathOrRule = ensurePath2D(pathOrRule)
+  }
+  if (arguments.length === 0) {
+    return _clip.call(this)
+  } else if (arguments.length === 1) {
+    return _clip.call(this, pathOrRule)
+  } else {
+    return _clip.call(this, pathOrRule, rule)
+  }
+}
+
+// Override isPointInPath to handle Path2D-like objects from bundled environments
+CanvasRenderingContext2D.prototype.isPointInPath = function isPointInPath(pathOrX, xOrY, yOrRule, rule) {
+  if (pathOrX && typeof pathOrX === 'object' && typeof pathOrX !== 'string') {
+    pathOrX = ensurePath2D(pathOrX)
+  }
+  if (arguments.length === 2) {
+    return _isPointInPath.call(this, pathOrX, xOrY)
+  } else if (arguments.length === 3) {
+    return _isPointInPath.call(this, pathOrX, xOrY, yOrRule)
+  } else {
+    return _isPointInPath.call(this, pathOrX, xOrY, yOrRule, rule)
+  }
+}
+
+// Override isPointInStroke to handle Path2D-like objects from bundled environments
+CanvasRenderingContext2D.prototype.isPointInStroke = function isPointInStroke(pathOrX, xOrY, y) {
+  if (pathOrX && typeof pathOrX === 'object' && typeof pathOrX !== 'string') {
+    pathOrX = ensurePath2D(pathOrX)
+  }
+  if (arguments.length === 2) {
+    return _isPointInStroke.call(this, pathOrX, xOrY)
+  } else {
+    return _isPointInStroke.call(this, pathOrX, xOrY, y)
+  }
+}
+
 function createCanvas(width, height, flag) {
   const isSvgBackend = typeof flag !== 'undefined'
   return isSvgBackend ? new SVGCanvas(width, height, flag) : new CanvasElement(width, height)
